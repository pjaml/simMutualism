#+title: Mutualism IDE Model

* Model

** ODE parameters

#+begin_src matlab :tangle mutual_ide.m

clearvars
clc
%% original function parameters

iterations = 60;
tspan = [0, 10];
r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.9 0.1];
comp_12 = 0.0;
comp_21 = 0.0;

% format spec for floating point values in filenames
fspec = '%.2f';
#+end_src

** Initialization

=linspace(x1, x2, n)= creates a vector of =n= points between points =x1= and =x2=. Spacing between points is =(x2-x1)/(n-1)=. See [[https://in.mathworks.com/help/matlab/ref/linspace.html][linspace documentation]].

#+begin_src matlab :tangle mutual_ide.m

%% Initialize parameters
lowval = 1e-9;
diameter = 1200;  %total size of landscape along positive x-axis (so technically half the size of the total landscape)
nodes = (2^16)+1; %total points in space -- 65537
radius = diameter/2;
x = linspace(-radius,radius,nodes);
x2 = linspace(-diameter,diameter,2*nodes-1);
dx = diameter/(nodes-1);
[speed_inst_P,speed_av_P, speed_inst_F1,speed_av_F1, speed_inst_F2, speed_av_F2] = deal(zeros(1,iterations)); %assign initializing values to each of the arrays
[xright_P,xright_F1, xright_F2] = deal(zeros(1,iterations+1)); %array with 1 row and 201 columns. tells us the farthest a population has reached
[n_P,n_F1, n_F2] = deal(zeros(iterations+1,length(x))); %array with 201 rows and 65537 columns. tells us population density at each node along column and each time step/iteration is one row. define ,f_P_all,f_F_all if you wish to do post census calculations

#+end_src

*** Dispersal kernels

#+begin_src matlab :tangle mutual_ide.m
sigma_sq = 0.25; % Dispersal variance

% gaussian dispersal kernels
k_P = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
k_F1 = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
k_F2 = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);

#+end_src

*** Initial population densities

#+begin_src matlab :tangle mutual_ide.m
% SET THE INITIAL CONDITIONS
irad = 2; % Initial condition range
idens = [0.1,0.1,0.1];
ncrit = 0.05; % critical threshold for edge of wave
temp_P = find(abs(x) <= irad); %locate all values in the array x that lie b/w +irad and -irad units of space
temp_F1 = find(abs(x) <= irad);
temp_F2 = find(abs(x) <= irad);

n_P(1,temp_P) = idens(1)*normpdf(x(temp_P),0,1); %Computes pdf values evaluated at the values in x i.e. all x(temp) values for the normal distribution with mean 0 and standard deviation 1.
n_F1(1,temp_F1) = idens(2)*normpdf(x(temp_F1),0,1);
n_F2(1,temp_F2) = idens(3)*normpdf(x(temp_F2),0,1);

#+end_src

*** Initial front location

#+begin_src matlab :tangle mutual_ide.m
% FIND THE INITIAL FRONT LOCATION
jj_P = find(n_P(1,:) >= ncrit,1,'last'); %find the farthest distance travelled by the population above a certain threshold density and assign it to jj
jj_F1 = find(n_F1(1,:) >= ncrit,1,'last');
jj_F2 = find(n_F2(1,:) >= ncrit,1,'last');

if jj_P %the initial front is obtained from initialization which will be in the first row of 'n'
  xright_P(1) = interp1(n_P(1,jj_P:jj_P+1),x(jj_P:jj_P+1),ncrit);
end
if jj_F1
  xright_F1(1) = interp1(n_F1(1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),ncrit);
end

if jj_F2
  xright_F2(1) = interp1(n_F2(1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),ncrit);
end

#+end_src

** Growth and dispersal

#+begin_src matlab :tangle mutual_ide.m

%% Looping for growth and dispersal
for i = 1:iterations
    %Growth
    y0 = [n_P(i,:);n_F1(i,:);n_F2(i,:)];
    y0 = reshape(y0, 3*length(y0), 1); % reshape happens such that 3 consecutive rows for n_P, n_F1, and n_F2 values are stacked
    [t,y] = ode45(@(t,y) odephenotypes(t,y,r_p,r_f,alpha_pf,alpha_fp,q1,q2,beta1,beta2,c1,c2,d_p,d_f,h1,h2,e1,e2,nodes,dep_p,dep_f, comp_12, comp_21), tspan, y0); %remember to alter where the dep_p and dep_f are being called from

    % We just want the results of the growth phase (end)
    f_P = y(end,(1:3:end)); % final row; element 1, +3, elem. 4, etc. until end
    f_F1 = y(end,(2:3:end));
    f_F2 = y(end,(3:3:end));

%   DISPERSAL
    n1_P = fft_conv(k_P,f_P);   % dispersing individuals
    n1_F1 = fft_conv(k_F1,f_F1);
    n1_F2 = fft_conv(k_F2,f_F2);

    n_P(i+1,:) = dx*n1_P(nodes:length(x2)); %the convolution apparently doubles the length of the array?
    n_F1(i+1,:) = dx*n1_F1(nodes:length(x2));
    n_F2(i+1,:) = dx*n1_F2(nodes:length(x2));

    n_P(i+1,1) = n_P(i+1,1)/2; n_P(i+1,nodes) = n_P(i+1,nodes)/2; %The population density at the edges is halved
    n_F1(i+1,1) = n_F1(i+1,1)/2; n_F1(i+1,nodes) = n_F1(i+1,nodes)/2;
    n_F2(i+1,1) = n_F2(i+1,1)/2; n_F2(i+1,nodes) = n_F2(i+1,nodes)/2;

    temp_P = find(n_P(i+1,:) < lowval); %gives location of random places where numbers are above zero due to some numerical errors
    temp_F1 = find(n_F1(i+1,:) < lowval);
    temp_F2 = find(n_F2(i+1,:) < lowval);

    n_P(i+1,temp_P) = zeros(size(n_P(i+1,temp_P))); %set the places with those numerical errors to zero
    n_F1(i+1,temp_F1) = zeros(size(n_F1(i+1,temp_F1)));%delete this for STE
    n_F2(i+1,temp_F2) = zeros(size(n_F2(i+1,temp_F2)));%delete this for STE

    jj_P = find(n_P(i+1,:) >= ncrit,1,'last');
    jj_F1 = find(n_F1(i+1,:) >= ncrit,1,'last');
    jj_F2 = find(n_F2(i+1,:) >= ncrit,1,'last');

    if jj_P
         xright_P(i+1) = interp1(n_P(i+1,jj_P:jj_P+1),x(jj_P:jj_P+1),ncrit);
    end

    if jj_F1
         xright_F1(i+1) = interp1(n_F1(i+1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),ncrit);
    end

    if jj_F2
         xright_F2(i+1) = interp1(n_F2(i+1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),ncrit);
    end

    speed_av_P(i) = (xright_P(i+1)-xright_P(1))/i; %latest position of wave edge - initial position of wave edge divided by time
    speed_inst_P(i) = xright_P(i+1)-xright_P(i);

    speed_inst_F1(i) = xright_F1(i+1)-xright_F1(i);
    speed_av_F1(i) = (xright_F1(i+1)-xright_F1(1))/i; %latest position of wave edge - initial position of wave edge divided by time

    speed_inst_F2(i) = xright_F2(i+1)-xright_F2(i);
    speed_av_F2(i) = (xright_F2(i+1)-xright_F2(1))/i; %latest position of wave edge - initial position of wave edge divided by time

    %save(strcat(['mandm_yescost_depP=' num2str(dep_p) '_depF=' num2str(dep_f) '.mat']))
    %save mandm_nocost_yesdep.mat
#+end_src

*** Steady state check

Use =sqrt(var(speed_inst_F1(end-9:end)))= to get the variation in range expansion speed for the last 10 iterations, and determine if this is less than some tolerance.

#+begin_src matlab :tangle mutual_ide.m
    %% Adds further iterations if steady states are not reached
    % if (i == iterations)
    %     tol = 1e-04;
    %     if ~(abs(speed_inst_P(i) - speed_inst_P(i-1)) < tol) || ~(abs(speed_inst_F1(i) - speed_inst_F1(i-1)) < tol) || ~(abs(speed_inst_F2(i) - speed_inst_F2(i-1)) < tol)

    %         if iterations > 400
    %             iterations = 500;
    %         else
    %             iterations = iterations + 20;
    %         end

    %         % extend the sizes of the relevant vectors & matrices
    %         [speed_inst_P(length(speed_inst_P)+1:iterations), speed_av_P(length(speed_av_P)+1:iterations), speed_inst_F1(length(speed_inst_F1)+1:iterations), speed_av_F1(length(speed_av_F1)+1:iterations), speed_inst_F2(length(speed_inst_F2)+1:iterations), speed_av_F2(length(speed_av_F2)+1:iterations)] = deal(0);
    %         [xright_P(length(xright_P)+1:iterations+1),xright_F1(length(xright_F1)+1:iterations+1), xright_F2(length(xright_F2)+1:iterations+1)] = deal(0);

    %         [n_P(height(n_P)+1:iterations+1,:), n_F1(height(n_F1)+1:iterations+1,:), n_F2(height(n_F2)+1:iterations+1,:)] = deal(zeros((iterations+1)-height(n_P), length(n_P)));
    %     else
    %         break
    %     end
    % end


end

%% Save a mat file with the current parameter values
save(strcat(['~/sweep2/mat_files/comp_pheno_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.mat']));

#+end_src

** Function to classify outcome (=det_outcome.m=)

#+begin_src matlab :tangle det_outcome.m

%% Function to classify outcome of a given simulation
function outcome = det_outcome(n_P, n_F1, n_F2, ncrit)

    % get the final population densities of P, F1, and F2
    fin_P = n_P(end,:);
    fin_F1 = n_F1(end,:);
    fin_F2 = n_F2(end,:);

    % get the ranges where F1 and F2 populations are above the threshold
    rangeP = find(fin_P >= ncrit);
    rangeF1 = find(fin_F1 >= ncrit);
    rangeF2 = find(fin_F2 >= ncrit);

    max_range = max(length(rangeF1), length(rangeF2));
    % max_range = size(rangeP);

    % if F2 is below the threshold across the total range, then classify as
    % F1 dominance
    if isempty(rangeF2)
        outcome = 1; % F1 dominance

    % if F1 is below the threshold across the total range, then classify as
    % F2 dominance
    elseif isempty(rangeF1)
        outcome = 2; % F2 dominance

    % elseif length(rangeF1)/max_range >= 0.95 & length(rangeF2)/max_range >= 0.95

    % find the range of values in rangeF1 or rangeF2 but not both
    % if the proportion of this range over the total range is less than
    % the arbitrary value 0.05, we call it local coexistence
    elseif length(setxor(rangeF1, rangeF2))/max_range < 0.05
        outcome = 3; % Local coexistence

    % if F1 is above threshold and F2 is below threshold or F2 is above
    % threshold and F1 is below threshold

    % elseif isempty(find(fin_F2(setxor(rangeF1, rangeF2)) >= ncrit))

    % we find at least some F1 dominance
    elseif not(isempty(intersect(rangeF1, setxor(rangeF1, rangeF2))))

        % we find at least some F2 dominance
        if not(isempty(intersect(rangeF2, setxor(rangeF1, rangeF2))))
            outcome = 6; % regional coexistence

        % no F2 dominance
        else
            outcome = 4; % Local coexistence + F1 dominance
        end

    elseif not(isempty(intersect(rangeF2, setxor(rangeF1, rangeF2))))
        outcome = 5; % Local coexistence + F2 dominance

    else
        outcome = 7; % unknown
    end
end
#+end_src

* Figures

** 3D density vs. space vs. time plots


#+begin_src matlab :tangle mutual_ide.m


%% Figure for species P
figure(1);
clf
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_P;
nlow(n_P>=ncrit) = NaN;
n_P(n_P<ncrit) = NaN;
hold on
for i = 1:5:60
     plot3(xx(i,:),tt(i,:),n_P(i,:),'b', 'LineWidth', 3.0);
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end
% plot3(xright_P(1:11),0:10,ncrit*ones(1,11),'k');
    axis([-120 120 0 iterations 0 6.25]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('density');
    % title('Species P');
    view(30,30);

%% Figure for species F1
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_F1;
nlow(n_F1>=ncrit) = NaN;
n_F1(n_F1<ncrit) = NaN;
hold on
for i = 1:5:60
     plot3(xx(i,:),tt(i,:),n_F1(i,:),'r','LineWidth', 3.0);
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end

% plot3(xright_F1(1:11),0:10,ncrit*ones(1,11),'k');
    % axis([-15 15 0 10 0 5]);
    % xlabel('space (x)');
    % ylabel('time (t)');
    % zlabel('species F1 density (n_F1)');
    % view(30,30);
    % title('Species F1');

%% Figure for species F2
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_F2;
nlow(n_F2>=ncrit) = NaN;
n_F2(n_F2<ncrit) = NaN;
hold on
for i = 1:5:60
     plot3(xx(i,:),tt(i,:),n_F2(i,:),'g', 'LineWidth', 3.0);
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end

% plot3(xright_F2(1:11),0:100,ncrit*ones(1,11),'k');
    % axis([-15 15 0 10 0 5]);
    % xlabel('space (x)');
    % ylabel('time (t)');
    % zlabel('species F2 density (n_F2)');
    % view(30,30);
    % title('Species F2');
hold off

#+end_src

** Speed vs. time

#+begin_src matlab :tangle mutual_ide.m


clf
plot(1:iterations, speed_inst_P, 1:iterations, speed_inst_F1, 1:iterations, speed_inst_F2);
legend('P', 'F1', 'F2');
title(strcat(['Spread speed vs. time (tau21=' num2str(comp_21) ', tau12=' num2str(comp_12) ')']));
xlabel('iterations');
ylabel('speed');

savefig(strcat(['comp_pheno_model/speed_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.fig']));

#+end_src

** N spatial distribution

Three save functions are called:
- =save()= saves the current parameter values in a =.mat= file (with relevant parameter values in the filename)
- =savefig()= saves the matlab figure so we can easily view and manipulate it in matlab
- =saveas()= saves the figure as a PNG

 #+begin_src matlab :tangle mutual_ide.m

clf
hold on
plot(n_P(end,:));
plot(n_F1(end,:));
plot(n_F2(end,:));
legend('P', 'F1', 'F2');
title(strcat(['N vs. x (tau21=' num2str(comp_21) ', tau12=' num2str(comp_12) ')']));
hold off

savefig(strcat(['comp_pheno_model/N_v_x_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.fig']));

% Save a PNG file
% saveas(gcf, strcat(['comp_pheno_model/comp_pheno_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.png']));

#+end_src

** Range vs. time

This plot shows how the overall range of each species changes over time.

In order to obtain the range of a species at a given time, you could find all the spatial points in the /n/ matrices (columns) where the value is greater than some minimum population. =n_P= is a matrix with rows for each iteration and columns for each spatial point.

Does range size need to be contiguous? In other words, if F1 is only present at the edges, could you total its ranges at each edge and call that its "range size"?

#+begin_src matlab :tangle mutual_ide.m

for i = 1:iterations+1

    rangeP(i) = length(find(n_P(i,:) >= ncrit));
    rangeF1(i) = length(find(n_F1(i,:) >= ncrit));
    rangeF2(i) = length(find(n_F2(i,:) >= ncrit));
end

clf
plot(1:iterations+1, [rangeP; rangeF1; rangeF2]);
xlabel('iterations');
ylabel('range size');
title(strcat(['Range size vs. time (tau21=' num2str(comp_21) ', tau12=' num2str(comp_12) ')']));
legend('P', 'F1', 'F2');

savefig(strcat(['comp_pheno_model/range_size_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.fig']));

#+end_src

** Populations vs. time plot (=pheno_pop_vs_time.m=)

#+begin_src matlab :tangle pheno_pop_vs_time.m

% time span
tspan = 0.0:0.1:100.0;

% initial populations
initpop = [2.0; 2.0; 2.0];

r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];

nodes = 1;

[t,y] = ode45(@(t,y) odephenotypes(t,y,r_p,r_f,alpha_pf,alpha_fp,q1,q2,beta1,beta2,c1,c2,d_p,d_f,h1,h2,e1,e2,nodes,dep_p,dep_f, comp_12, comp_21), tspan, initpop);

P = y(:,1);
F1 = y(:,2);
F2 = y(:,3);

% generate plot
figure;
plot(t, [P, F1, F2]);
legend('P', 'F1', 'F2');
xlabel('time');
ylabel('population');


#+end_src

** Phase space plot - P vs. F1 vs. F2 (=phenophase.m=)

In the two-species mutualism model, we took a range of possible starting population values (this is what we passed to the =meshgrid()= function to generate a matrix for each species). We then sent these matrices to our ODE function, which returned the growth rates for each combination of starting population values—this is how we got our vector field arrows.

*** Initial setup for 3D phase space plot

Here you generate the vector field with the =meshgrid()= and =quiver()= functions

#+begin_src matlab :tangle phenophase.m

maxpop = 10.0;
popRange = 0.0:0.5:maxpop;

[P, F1, F2] = meshgrid(popRange);

r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];
comp_12 = 1.0;
comp_21 = 4.0;

ystart = [P(:).'; F1(:).'; F2(:).'];
ystart = reshape(ystart, 3*length(ystart), 1);

dy = odephenotypes(0, ystart, r_p, r_f, alpha_pf, alpha_fp, q1, q2, beta1, beta2, c1, c2, d_p, d_f, h1, h2, e1, e2, length(P(:).'), dep_p, dep_f, comp_12, comp_21);

dP = reshape(dy((1:3:end),:), length(P), length(P), length(P));
dF1 = reshape(dy((2:3:end),:), length(P), length(P), length(P));
dF2 = reshape(dy((3:3:end),:), length(P), length(P), length(P));

u = dP ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
v = dF1 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
w = dF2 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);

figure;
quiver3(P, F1, F2, u, v, w, 0.35);
xlabel('P');
ylabel('F1');
zlabel('F2');
hold on;

#+end_src

*** Plot isoclines

#+begin_src matlab :tangle phenophase.m

syms x y z
eq1 = ((1-dep_p).*r_p + dep_p .* (c1.*((alpha_pf(1).*y)./(h2(1)+y) + (alpha_pf(2).*z)./(h2(2)+z)))- ((dep_f(1)+dep_f(2))/2) .*(q1.*(beta1.*(y + z)./(e1+x)))-(d_p.*x));
eq2 = ((1-dep_f(1)).*r_f(1) + c2 .*(dep_f(1).*(alpha_fp(1).*x)./(h1(1)+x))-q2.*(dep_p.*((beta2(1).*x)./(e2(1)+y))) -(d_f(1).*y));
eq3 = ((1-dep_f(2)).*r_f(2) + c2 .*(dep_f(2).*(alpha_fp(2).*x)./(h1(2)+x))-q2.*(dep_p.*((beta2(2).*x)./(e2(2)+z))) -(d_f(2).*z));

fimplicit3(eq1, [0 maxpop]);
fimplicit3(eq2, [0 maxpop]);
fimplicit3(eq3, [0 maxpop]);

hold off;

#+end_src



** "Meta" graph (=sweep_outcomes.m=)

#+begin_src matlab :tangle sweep_outcomes.m

clear all

fspec = '%.2f';
tau_12_list = [0.00:0.01:0.40];
tau_21_list = [0.00:0.01:0.40];

outcomes = zeros(length(tau_12_list), length(tau_21_list));

for ii = 1:length(tau_12_list)
    for jj = 1:length(tau_21_list)

        load(strcat(['~/sweep/mat_files/comp_pheno_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=' num2str(tau_12_list(ii), fspec) '_comp_21=' num2str(tau_21_list(jj), fspec) '.mat']));

        outcomes(ii,jj) = det_outcome(n_P, n_F1, n_F2, 0.05);

    end
end

figure(1)
heatmap(tau_12_list, fliplr(tau_21_list), rot90(outcomes));
xlabel('tau_{12}');
ylabel('tau_{21}');

#+end_src

* Parameter sweep

** Sweep script

#+begin_src shell :tangle sweep/tau_sweep.sh

#!/bin/bash

BASEDIR=~/sweep

ORIGFILE=$BASEDIR/mutual_comp_model.m
JOBSCRIPT=$BASEDIR/tau_jobscript.sh

chmod 775 $JOBSCRIPT

# create a directory to store all the .m and .mat files
mkdir -p $BASEDIR/{m_files,mat_files}

# create directories to store symlinks to the various figures
mkdir -p $BASEDIR/figures/{n_v_x,range,speed}/png

# create a directory to store each simulation
mkdir -p $BASEDIR/tau_sweep

# Loop through all the tau values you want to simulate
for comp21 in $(seq 0.0 0.01 0.4);
do
    for comp12 in $(seq 0.13 0.01 0.29);
    do

	# Format the comp12 and comp21 floating point values with the same format spec as the MATLAB files
	printf -v fcomp12 '%.2f' $comp12
	printf -v fcomp21 '%.2f' $comp21

        # Check to see if the current parameter value exists as a file (i.e. it's already been run on a previous sweep)
        # If it exists, skip it
        PARAMETERFILE=$BASEDIR/tau_sweep/mcm_comp21=${fcomp21}_comp12=${fcomp12}
        if [ -f "$PARAMETERFILE" ]; then
                continue
        else
                # create a directory to hold all files for each simulation
                mkdir -p $PARAMETERFILE

                # Replace the decimal values after comp_12 and comp_21 in the original .m file with the
                # current for loop values and create a new .m file with these values in the filename
                # then update .m file to save newly generated mat, fig, and png files to directory created above
sed -r "s/(comp_12\s*=\s*)[0-9]+\.?[0-9]*/\1${fcomp12}/; s/(comp_21\s*=\s*)[0-9]+\.?[0-9]*/\1${fcomp21}/; s/comp_pheno_model/tau_sweep\/mcm_comp21=${fcomp21}_comp12=${fcomp12}/" <$ORIGFILE >$BASEDIR/m_files/mcm_comp21=${fcomp21}_comp12=${fcomp12}.m


                chmod 775 $BASEDIR/m_files/mcm_comp21=${fcomp21}_comp12=${fcomp12}.m

                # Append instructions for the new .m file to the MSI batch job script


                # This updates the job script to use the current sim's values
                sed -i -r "s/(comp[_]?12=)[0-9]+\.?[0-9]*/\1${fcomp12}/g; s/(comp[_]?21=)[0-9]+\.?[0-9]*/\1${fcomp21}/g" $JOBSCRIPT

                sbatch $JOBSCRIPT
        fi
    done
done

#+end_src

** Slurm job script

Note that the $SBATCH lines *must* be at the top of the script. Anything before that will break Slurm.

#+begin_src shell :tangle sweep/tau_jobscript.sh

#!/bin/bash -l
#SBATCH --time=24:00:00
#SBATCH --ntasks=16
#SBATCH --mem=20g
#SBATCH --tmp=20g
#SBATCH --mail-type=NONE
#SBATCH --mail-user=lutzx119@umn.edu

BASEDIR=~/sweep
module load matlab
matlab -nodisplay -nodesktop -nosplash -r "maxNumCompThreads(1)"<$BASEDIR/m_files/mcm_comp21=0.40_comp12=0.40.m

# create a link to this sim's mat file in the mat_files directory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/comp_pheno_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.mat mat_files/.

# create a link to this sim's range plot in the figures/range directory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/range_size_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.fig figures/range/.
# put the png file in the png subdirectory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/range_size_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.png figures/range/png/.

# create a link to this sim's N vs x plot in the figures/n_v_x directory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.fig figures/n_v_x/.
# put the png file in the png subdirectory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.png figures/n_v_x/png/.

# create a link to this sim's speed plot in the figures/speed directory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/speed_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.fig figures/speed/.
# put the png file in the png subdirectory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/speed_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.png figures/speed/png/.

#+end_src

* System of Equations (=odephenotypes.m=)

** Function definition

Note that now =r2=, =alpha12=, =alpha21=, =beta2=, =d2=, =h1=, =h2=, =e2=, and =dep_f= are /1x2/ vectors. The first value is for $F_1$, the second is for $F_2$ (e.g. =r2(1)= if $F_2$'s growth rate)

#+begin_src matlab :tangle odephenotypes.m

function dydt = odephenotypes(t,y,r1,r2,alpha12,alpha21,q1,q2,beta1,beta2,c1,c2,d1,d2,h1,h2,e1,e2,nodes,dep_p,dep_f, comp_12, comp_21)
y = reshape(y,3,nodes);
dydt  = zeros(size(y));

#+end_src

** Species /P/

$$
\frac{dP}{dt} = P\left [
(1 - \delta_P) r_P + \delta_P \left( c_1 \left[\frac{\alpha_{PF_1} F_1}{h_P_1 + F_1}  + \frac{\alpha_{PF_2} F_2}{h_P_2 + F_2} \right] \right) -
\left(\frac{\delta_{F1} + \delta_{F2}}{2} \right) \left( q_1 \left[ \frac{\beta_{PF} (F_1 + F_2)}{e_P + P} \right] \right) - d_P P
\right]
$$

#+begin_src matlab :tangle odephenotypes.m

% rename variables so equations are easier to read
P = y(1,:);
F1 = y(2,:);
F2 = y(3,:);

dydt(1,:) = P.*((1-dep_p)*r1 + dep_p * (c1*((alpha12(1).*F1)./(h2(1)+F1) + (alpha12(2).*F2)./(h2(2)+F2)))- ((dep_f(1)+dep_f(2))/2) *(q1*(beta1.*(F1 + F2)./(e1+P)))-(d1.*P));

#+end_src

** Species /F/, Phenotype 1

$$
\frac{dF_1}{dt} = F_1[(1 - \delta_{F_1})r_{F_1} + \delta_{F_1} \left( c_2 \left[\frac{\alpha_{F_1P}P}{h_{F_1} + P} \right] \right) - \delta_P \left(q_2  \left[ \frac{\beta_{F_1P}P}{e_{F_1} + F_1} \right] \right) - \tau_{12}F_2 - d_{F_1}F_1]
$$

#+begin_src matlab :tangle odephenotypes.m

dydt(2,:) = F1.*((1-dep_f(1))*r2(1) + c2 *(dep_f(1)*(alpha21(1).*P)./(h1(1)+P))-q2*(dep_p*((beta2(1).*P)./(e2(1)+F1))) -(comp_12.*F2) -(d2(1).*F1));

% Testing no negative effect of dependence on intrinsic growth rate
%dydt(2,:) = F1.*(r2(1) + c2 *(dep_f(1)*(alpha21(1).*P)./(h1(1)+P))-q2*(dep_p*((beta2(1).*P)./(e2(1)+F1))) -(comp_12.*F2) -(d2(1).*F1));
#+end_src

** Species /F/, Phenotype 2

$$
\frac{dF_2}{dt} = F_2[(1 - \delta_{F_2})r_{F_2} + \delta_{F_2} \left(c_2 \left[\frac{\alpha_{F_2P}P}{h_{F_2} + P} \right] \right) - \delta_P \left(q_2  \left[ \frac{\beta_{F_2P}P}{e_{F_2} + F_2} \right] \right) - \tau_{21}F_1 - d_{F_2}F_2]
$$

#+begin_src matlab :tangle odephenotypes.m

dydt(3,:) = F2.*((1-dep_f(2))*r2(2) + c2 *(dep_f(2)*(alpha21(2).*P)./(h1(2)+P))-q2*(dep_p*((beta2(2).*P)./(e2(2)+F2))) - (comp_21.*F1) -(d2(2).*F2));

% Testing no negative effect of dependence on intrinsic growth rate
%dydt(3,:) = F2.*(r2(2) + c2 *(dep_f(2)*(alpha21(2).*P)./(h1(2)+P))-q2*(dep_p*((beta2(2).*P)./(e2(2)+F2))) - (comp_21.*F1) -(d2(2).*F2));
#+end_src

** Reshape

#+begin_src matlab :tangle odephenotypes.m

dydt = reshape(dydt,3*nodes,1);
end

#+end_src

* Results

** Table of results

=comp_12= is how F2 negatively impacts F1, and =comp_21= is how F1 negatively impacts F2 through competition.

| dep_f(1) | dep_f(2) | alpha21(1) | alpha21(2) | comp_12 | comp_21 | result  | dom. pheno |
|----------+----------+------------+------------+---------+---------+---------+------------|
|      0.1 |      0.9 |        0.5 |        0.5 |     0.5 |     0.4 | dom     | F1         |
|      0.1 |      0.9 |        0.5 |        0.5 |     0.2 |     0.1 | dom     | F1         |
|      0.1 |      0.9 |        0.5 |        0.5 |     0.1 |     0.2 | dom     | F2         |
|      0.1 |      0.9 |        0.5 |        0.5 |    0.01 |    0.02 | loc     | F2         |
|      0.5 |      0.9 |        0.5 |        0.5 |       1 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.8 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.5 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.4 |     2.3 | dom     | F2         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.4 |       1 | dom     | F2         |
|      0.6 |      0.9 |        0.5 |        0.5 |    0.08 |    0.04 | loc     | F1         |
|      0.6 |      0.9 |        0.5 |        0.5 |    0.08 |    0.03 | loc     | F2         |
|      0.7 |      0.9 |        0.5 |        0.5 |     0.1 |     0.2 | dom     | F2         |
|      0.7 |      0.9 |        0.5 |        0.5 |    0.01 |    0.02 | loc     | F2         |
|      0.9 |      0.6 |        0.5 |        0.5 |    0.08 |    0.04 | dom/loc | F1         |
|      0.9 |      0.6 |        0.5 |        0.7 |    0.08 |    0.04 | loc     | F1/F2      |
|      0.9 |      0.6 |        0.3 |        0.7 |    0.08 |    0.04 | dom/loc | F2         |
|      0.9 |      0.6 |        0.3 |        0.9 |    0.08 |    0.04 | dom/loc | F2         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.09 |    0.01 | dom     | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.07 |    0.01 | dom/loc | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.04 |    0.01 | dom/loc | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.04 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |    0.04 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |    0.07 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |     0.1 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |     0.4 | reg     | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |     0.4 | dom     | F2         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.06 | dom/loc | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.09 | dom/loc | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |     0.2 | reg     | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.03 | dom/loc | F1/F2      |

** Interpretation

If we plot the two competition factors F1 and F2, we can determine where we find local coexistence, regional coexistence, and dominance. What we found is not entirely what we expected (specifically in the upper right region), where the competition factors are equal.



*** Defining local and regional coexistence

/Regional coexistence/ could be defined as both phenotypes being completely dominant in a portion of the total range at steady state.

/Local coexistence/ occurs when both phenotypes occupy the majority of the total range together at steady state.

*** Do we need 𝛅?



** 𝛕 sweep results

*** Interesting plots

**** Regional coexistence

=tau12 = 0.21=

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.21_comp_21=0.23.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.22_comp_21=0.25.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.23_comp_21=0.12.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.23_comp_21=0.27.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.24_comp_21=0.29.png]]

=tau12 = 0.24=

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.25_comp_21=0.31.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.27_comp_21=0.36.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]

[[~/sweep2/figures/range/png/range_size_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]

[[~/sweep2/figures/speed/png/speed_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]


** Iterations issue

In order to see what happens in areas of regional coexistence over the long-term, we're attempting to run these simulations with 1000 iterations. Using the m file as-is, we get the error: ~Index in position 2 exceeds array bounds (must not exceed 65537)~

Clearly this is an issue with the number of nodes or the diameter.

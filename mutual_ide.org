#+title: Mutualism Project Code

* Simulation

Here we simulate the outcome of many generations of growth-dispersal cycles for three mutualist species. The =simMutualism()= function can take a number of optional arguments.

#+begin_src matlab :tangle simMutualism.m :comments link
function simMutualism(outputDir, varargin)

% we save the given parameters to a variable so we can use them to
% name files and label plots
parameters = varargin;
#+end_src

** Parameters

*** Simulation parameters

The number of growth-dispersal cycles (i.e. iterations) will change based on whether a steady state is reached for all three species. A species reaches a steady state when the variance between the last 10 spread speed values is at or below some threshold.

So the number of iterations defined here is just the /minimum/ number of iterations that a simulation will run. We also set the maximum number of iterations, so even if a steady state isn't reached, the simulation will end after this many cycles. This value is also used to allocate space in a number of arrays used in the simulation. It's faster (although more costly in memory) to preallocate the maximum number of rows we may need to use, rather than to try and increase the size of several large arrays.

We also define the number of additional iterations (=iterationStep=) to add to the simulation before checking for steady states again.

#+begin_src matlab :tangle simMutualism.m
%% for simulation

p = inputParser;
p.KeepUnmatched = true;

% minimum number of cycles of growth and dispersal
addParameter(p, 'iterations', 60);
addParameter(p, 'maxIterations', 500);
addParameter(p, 'iterationStep', 100);
addRequired(p, 'outputDir', @isfolder);

parse(p, outputDir, varargin{:});

% I wish I knew a better way to get rid of all the p.Results that get attached inputParser parameters
iterations = p.Results.iterations;
maxIterations = p.Results.maxIterations;
iterationStep = p.Results.iterationStep;
outputDir = p.Results.outputDir;

% threshold for speed variance at steady state
steadyStateThreshold = 1e-04;

#+end_src

We set this =fspec= variable so that automatically generated filenames use a standardized format for values. This is necessary for the parameter sweep script to work properly.

#+begin_src matlab :tangle simMutualism.m
% format spec for floating point values in filenames
fspec = '%.2f';
#+end_src

*** Space parameters

Here we create the one-dimensional landscape in which the species will disperse.

=linspace(x1, x2, n)= creates a vector of =n= points between points =x1= and =x2=. Spacing between points is =(x2-x1)/(n-1)=. See [[https://in.mathworks.com/help/matlab/ref/linspace.html][linspace documentation]].

#+begin_comment
Why these specific values?

#+end_comment

#+begin_src matlab :tangle simMutualism.m

%% Initialize space parameters
lowval = 1e-9;
diameter = 1200;  %total size of landscape along positive x-axis (so technically half the size of the total landscape)
nodes = (2^16) + 1; %total points in space -- 65537
radius = diameter / 2;
x = linspace(-radius, radius, nodes);
x2 = linspace(-diameter, diameter, 2 * nodes - 1);
dx = diameter / (nodes - 1);

#+end_src

** Initialization

Here we initialize the arrays we'll use throughout the simulation. The speed arrays save the instantaneous or average spread speed of a species for each iteration. The range edge arrays keep track of the furthest spatial location on one side of a species' range. The /n/ population arrays keep track of each species' population density across the entire spatial range.

#+begin_src matlab :tangle simMutualism.m

[instantSpeedP, avgSpeedP, instantSpeedF1, avgSpeedF1, instantSpeedF2, avgSpeedF2] = deal(zeros(1, maxIterations)); % preallocate arrays for max possible iterations

[rangeEdgeP,rangeEdgeF1, rangeEdgeF2] = deal(zeros(1, maxIterations));

[nP, nF1, nF2] = deal(zeros(maxIterations, length(x)));

#+end_src

*** Dispersal kernels

We use a Gaussian dispersal kernel for each species. At some point we'll rewrite this to allow for other dispersal kernel functions.

#+begin_src matlab :tangle simMutualism.m
sigma_sq = 0.25; % Dispersal variance

% gaussian dispersal kernels
kP = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
kF1 = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
kF2 = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);

#+end_src

*** Initial population densities

We set the initial population densities across the spatial range.

#+begin_src matlab :tangle simMutualism.m
% SET THE INITIAL CONDITIONS
irad = 2; % Initial condition range
initDensities = [0.1,0.1,0.1];
nThreshold = 0.05; % critical threshold for edge of wave
temp_P = find(abs(x) <= irad); %locate all values in the array x that lie b/w +irad and -irad units of space
temp_F1 = find(abs(x) <= irad);
temp_F2 = find(abs(x) <= irad);

nP(1,temp_P) = initDensities(1) * normpdf(x(temp_P),0,1); %Computes pdf values evaluated at the values in x i.e. all x(temp) values for the normal distribution with mean 0 and standard deviation 1.
nF1(1,temp_F1) = initDensities(2) * normpdf(x(temp_F1),0,1);
nF2(1,temp_F2) = initDensities(3) * normpdf(x(temp_F2),0,1);

#+end_src

*** Initial front location

#+begin_src matlab :tangle simMutualism.m
% FIND THE INITIAL FRONT LOCATION
jj_P = find(nP(1,:) >= nThreshold,1,'last'); %find the farthest distance travelled by the population above a certain threshold density and assign it to jj
jj_F1 = find(nF1(1,:) >= nThreshold,1,'last');
jj_F2 = find(nF2(1,:) >= nThreshold,1,'last');

if jj_P %the initial front is obtained from initialization which will be in the first row of 'n'
  rangeEdgeP(1) = interp1(nP(1,jj_P:jj_P+1),x(jj_P:jj_P+1),nThreshold);
end
if jj_F1
  rangeEdgeF1(1) = interp1(nF1(1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),nThreshold);
end

if jj_F2
  rangeEdgeF2(1) = interp1(nF2(1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),nThreshold);
end

#+end_src

** Simulating growth and dispersal over many generations

#+begin_src matlab :tangle simMutualism.m
generation = 1;
%% Looping for growth and dispersal
while generation <= iterations

#+end_src

*** Growth phase

#+begin_src matlab :tangle simMutualism.m
    % for ode45
    tspan = [0, 10];

    %Growth
    y0 = [nP(generation,:);nF1(generation,:);nF2(generation,:)];

    % reshape happens such that 3 consecutive rows for nP, nF1, and nF2 values are stacked
    y0 = reshape(y0, 3*length(y0), 1);

    [t,y] = ode45(@(t,y) growthODEs(t,y), tspan, y0); %remember to alter where the dep_p and dep_f are being called from


    % We just want the results of the growth phase (end)
    fP = y(end,(1:3:end)); % final row; element 1, +3, elem. 4, etc. until end
    fF1 = y(end,(2:3:end));
    fF2 = y(end,(3:3:end));

#+end_src

*** Dispersal phase

#+begin_src matlab :tangle simMutualism.m
%   DISPERSAL
    n1P = fft_conv(kP,fP);   % dispersing individuals
    n1F1 = fft_conv(kF1,fF1);
    n1F2 = fft_conv(kF2,fF2);

    nP(generation + 1,:) = dx*n1P(nodes:length(x2)); %the convolution apparently doubles the length of the array?
    nF1(generation + 1,:) = dx*n1F1(nodes:length(x2));
    nF2(generation + 1,:) = dx*n1F2(nodes:length(x2));

    nP(generation + 1,1) = nP(generation + 1,1)/2; nP(generation + 1,nodes) = nP(generation + 1,nodes)/2; %The population density at the edges is halved

    nF1(generation + 1,1) = nF1(generation + 1,1)/2; nF1(generation + 1,nodes) = nF1(generation + 1,nodes)/2;

    nF2(generation + 1,1) = nF2(generation + 1,1)/2; nF2(generation + 1,nodes) = nF2(generation + 1,nodes)/2;

    temp_P = find(nP(generation + 1,:) < lowval); %gives location of random places where numbers are above zero due to some numerical errors
    temp_F1 = find(nF1(generation + 1,:) < lowval);
    temp_F2 = find(nF2(generation + 1,:) < lowval);

    nP(generation + 1,temp_P) = zeros(size(nP(generation + 1,temp_P))); %set the places with those numerical errors to zero
    nF1(generation + 1,temp_F1) = zeros(size(nF1(generation + 1,temp_F1)));%delete this for STE
    nF2(generation + 1,temp_F2) = zeros(size(nF2(generation + 1,temp_F2)));%delete this for STE

    jj_P = find(nP(generation + 1,:) >= nThreshold,1,'last');
    jj_F1 = find(nF1(generation + 1,:) >= nThreshold,1,'last');
    jj_F2 = find(nF2(generation + 1,:) >= nThreshold,1,'last');

    if jj_P
         rangeEdgeP(generation + 1) = interp1(nP(generation + 1,jj_P:jj_P + 1),x(jj_P:jj_P + 1),nThreshold);
    end

    if jj_F1
         rangeEdgeF1(generation + 1) = interp1(nF1(generation + 1,jj_F1:jj_F1 + 1),x(jj_F1:jj_F1 + 1),nThreshold);
    end

    if jj_F2
         rangeEdgeF2(generation + 1) = interp1(nF2(generation + 1,jj_F2:jj_F2 + 1),x(jj_F2:jj_F2 + 1),nThreshold);
    end

    avgSpeedP(generation) = (rangeEdgeP(generation + 1) - rangeEdgeP(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time
    instantSpeedP(generation) = rangeEdgeP(generation + 1) - rangeEdgeP(generation);

    instantSpeedF1(generation) = rangeEdgeF1(generation + 1) - rangeEdgeF1(generation);
    avgSpeedF1(generation) = (rangeEdgeF1(generation + 1) - rangeEdgeF1(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time

    instantSpeedF2(generation) = rangeEdgeF2(generation + 1) - rangeEdgeF2(generation);
    avgSpeedF2(generation) = (rangeEdgeF2(generation + 1) - rangeEdgeF2(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time
#+end_src

*** Determine whether to continue running the simulation for more iterations

#+begin_src matlab :tangle simMutualism.m
    % check for steady state, and determine whether to run for more generations
    if (generation == iterations)

        % if not all species at steady state
        if ~(isSpeciesSteadyState(instantSpeedP, steadyStateThreshold, generation) && isSpeciesSteadyState(instantSpeedF1, steadyStateThreshold, generation) && isSpeciesSteadyState(instantSpeedF2, steadyStateThreshold, generation))

            % iterations close to the max
            if iterations >= (maxIterations - iterationStep)
                iterations = maxIterations;
            else
                iterations = iterations + iterationStep;
            end
        end
    end

    generation = generation + 1;

% while loop end
end
#+end_src

*** Checking if a species is at a steady state

This function takes the spread speed values for a given species and checks to see if the variance in the last 10 values is at or below a threshold to determine whether a steady state has been reached.

#+begin_src matlab :tangle isSpeciesSteadyState.m
function isSteadyState = isSpeciesSteadyState(speed, tolerance, generation)
% takes a matrix of speed values and checks whether the variance in the last 10 values is at or below a threshold

    variance = sqrt(var(speed((generation - 9):generation)));

    if variance <= tolerance
        isSteadyState = true;
    else
        isSteadyState = false;
    end
end
#+end_src

*** Generate and save a mat file for the simulation

Using =maxIterations= to create the initial arrays means that these arrays may be storing many more rows than is actually necessary. Since we're saving these to mat files, we can reduce the size before saving by resizing the arrays.

Then we can save our results to a mat file, which can then be used to generate figures, identify outcomes, etc. The =filename= string can be reused for saving figures as well. It takes any explicitly defined parameters from the call to =simMutualism()= and appends the names and values to =filename=.

#+begin_src matlab :tangle simMutualism.m
%% Save a mat file with the current parameter values

nP = nP(1:(iterations + 1), :);
nF1 = nF1(1:(iterations + 1), :);
nF2 = nF2(1:(iterations + 1), :);

instantSpeedP(1, 1:(iterations + 1));
instantSpeedF1(1, 1:(iterations + 1));
instantSpeedF2(1, 1:(iterations + 1));

filename = strcat('results_', strjoin(string(parameters), '_'));

save(strcat(outputDir, filename, '.mat'), 'nP', 'nF1', 'nF2', 'iterations', 'nThreshold', 'instantSpeedP', 'instantSpeedF1', 'instantSpeedF2', 'filename', 'parameters', 'x');

% end of simMutualism function
end
#+end_src

* Growth Model

Here we define the growth of each species using a system of ODEs.

** System of Equations (=growthODEs.m=)

*** Function definition

With =varargin=, we can optionally use parameter values other than the defaults, e.g. =growthODEs(t, y, 'rP', 0.4)=. We need to use an [[https://www.mathworks.com/help/matlab/ref/inputparser.html][inputParser]] to manage the function's parameters.

#+begin_src matlab :tangle growthODEs.m

% function dydt = growthODEs(t, y, r1, r2, alpha12, alpha21, q1, q2, beta1, beta2, c1, c2, d1, d2, h1, h2,e1, e2, nodes, dep_p, dep_f, comp_12, comp_21)
function dydt = growthODEs(t, y, varargin)

#+end_src

*** Default parameter values

We set our default parameter values here. If the parameter is not explicitly defined in the function call, then these default values are used.

#+begin_src matlab :tangle growthODEs.m

    %% Default ODE parameter values

    default_nodes = (2^16) + 1;

    % intrinsic growth
    default_rP = 0.3;
    default_rF1 = 0.3;
    default_rF2 = 0.3;

    % mutualism benefits
    default_alphaPF1 = 0.5;
    default_alphaPF2 = 0.5;
    default_alphaF1P = 0.5;
    default_alphaF2P = 0.5;

    default_qP = 1.0;
    default_qF1 = 1.0;
    default_qF2 = 1.0;

    % mutualism costs
    default_betaP = 0.0;
    default_betaF1 = 0.0;
    default_betaF2 = 0.0;

    default_cP = 1.0;
    default_cF1 = 1.0;
    default_cF2 = 1.0;

    % death rate
    default_dP = 0.1;
    default_dF1 = 0.1;
    default_dF2 = 0.1;

    % saturation
    default_hPF1 = 0.3;
    default_hPF2 = 0.3;
    default_hF1P = 0.3;
    default_hF2P = 0.3;

    default_eP = 0.3;
    default_eF1 = 0.3;
    default_eF2 = 0.3;

    % = 0.0;
    default_deltaP = 0.0;
    default_deltaF1 = 0.9;
    default_deltaF2 = 0.1;

    % competition: tau12 is the effect F2 has on F1; tau21 is effect of F1 on F2
    default_tau12 = 0.0;
    default_tau21 = 0.0;

#+end_src

*** Adding parameters with =inputParser=

See [[https://www.mathworks.com/help/matlab/ref/inputparser.html][inputParser]] and [[https://www.mathworks.com/help/matlab/ref/inputparser.addparameter.html][addParameter]] documentation. By setting =p.KeepUnmatched = true=, we can pass along all the parameters given in the simMutualism function call and just ignore the ones that are not relevant to the ODE parameters.

#+begin_src matlab :tangle growthODEs.m

    p = inputParser;
    p.KeepUnmatched = true;

    addRequired(p, 't');
    addRequired(p, 'y');

    %% Optional ODE parameters

    addParameter(p, 'nodes', default_nodes);

    % intrinsic growth rates
    addParameter(p, 'rP', default_rP);
    addParameter(p, 'rF1', default_rF1);
    addParameter(p, 'rF2', default_rF2);

    % mutualism benefits
    addParameter(p, 'alphaPF1', default_alphaPF1);
    addParameter(p, 'alphaPF2', default_alphaPF2);
    addParameter(p, 'alphaF1P', default_alphaF1P);
    addParameter(p, 'alphaF2P', default_alphaF2P);

    addParameter(p, 'qP', default_qP );
    addParameter(p, 'qF1', default_qF1);
    addParameter(p, 'qF2', default_qF2);

    % mutualism costs
    addParameter(p, 'betaP', default_betaP);
    addParameter(p, 'betaF1', default_betaF1);
    addParameter(p, 'betaF2', default_betaF2);

    addParameter(p, 'cP', default_cP);
    addParameter(p, 'cF1', default_cF1);
    addParameter(p, 'cF2', default_cF2);

    % death rate
    addParameter(p, 'dP', default_dP);
    addParameter(p, 'dF1', default_dF1);
    addParameter(p, 'dF2', default_dF2);

    % saturation
    addParameter(p, 'hPF1', default_hPF1);
    addParameter(p, 'hPF2', default_hPF2);
    addParameter(p, 'hF1P', default_hF1P);
    addParameter(p, 'hF2P', default_hF2P);

    addParameter(p, 'eP', default_eP);
    addParameter(p, 'eF1', default_eF1);
    addParameter(p, 'eF2', default_eF2);

    % mutualism dependence
    addParameter(p, 'deltaP', default_deltaP);
    addParameter(p, 'deltaF1', default_deltaF1);
    addParameter(p, 'deltaF2', default_deltaF2);

    % competition
    addParameter(p, 'tau12', default_tau12);
    addParameter(p, 'tau21', default_tau21);

    parse(p, t, y, varargin{:});

    % relabel variables so they're easier to read in the equation

    t = p.Results.t;
    y = p.Results.y;
    nodes = p.Results.nodes;

    % intrinsic growth
    rP = p.Results.rP;
    rF1 = p.Results.rF1;
    rF2 = p.Results.rF2;

    % mutualism benefits
    alphaPF1 = p.Results.alphaPF1;
    alphaPF2 = p.Results.alphaPF2;
    alphaF1P = p.Results.alphaF1P;
    alphaF2P = p.Results.alphaF2P;

    qP = p.Results.qP;
    qF1 = p.Results.qF1;
    qF2 = p.Results.qF2;

    % mutualism costs
    betaP = p.Results.betaP;
    betaF1 = p.Results.betaF1;
    betaF2 = p.Results.betaF2;

    cP = p.Results.cP;
    cF1 = p.Results.cF1;
    cF2 = p.Results.cF2;

    % death rate
    dP = p.Results.dP;
    dF1 = p.Results.dF1;
    dF2 = p.Results.dF2;

    % saturation
    hPF1 = p.Results.hPF1;
    hPF2 = p.Results.hPF2;
    hF1P = p.Results.hF1P;
    hF2P = p.Results.hF2P;

    eP = p.Results.eP;
    eF1 = p.Results.eF1;
    eF2 = p.Results.eF2;

    % mutualism dependence
    deltaP = p.Results.deltaP;
    deltaF1 = p.Results.deltaF1;
    deltaF2 = p.Results.deltaF2;

    % competition: tau12 is the effect F2 has on F1; tau21 is effect of F1 on F2
    tau12 = p.Results.tau12;
    tau21 = p.Results.tau21;

    y = reshape(y,3,nodes);
    dydt  = zeros(size(y));


#+end_src

*** Species /P/


\begin{align*}
\frac{dP}{dt} = P\left[ (1 - \deltaP) r_P &+ \deltaP \left( c_1 \left[\frac{\alpha_{PF_1} F_1}{h_P_1 + F_1}  + \frac{\alpha_{PF_2} F_2}{h_P_2 + F_2} \right] \right) \\
&- \delta_{F1} \left( q_1 \left[ \frac{\beta_{P} F_1}{e_P + P} \right] \right) - \delta_{F2} \left( q_1 \left[ \frac{\beta_{P} F_2}{e_P + P} \right] \right) - d_{P} P \right]
\end{align*}

#+begin_src matlab :tangle growthODEs.m

    % rename variables so equations are easier to read
    P = y(1,:);
    F1 = y(2,:);
    F2 = y(3,:);

    dydt(1,:) = P .* ((1 - deltaP) * rP + deltaP * (cP * ((alphaPF1 .* F1) ./ (hPF1 + F1) + (alphaPF2 .* F2) ./ (hPF2 + F2))) - deltaF1 * (qP * (betaP .* F1 ./ (eP + P))) - deltaF2 * (qP * (betaP .* F2 ./ (eP + P))) - (dP .* P));

#+end_src

*** Species /F/, Phenotype 1

$$
\frac{dF_1}{dt} = F_1[(1 - \delta_{F_1})r_{F_1} + \delta_{F_1} \left( c_2 \left[\frac{\alpha_{F_1P}P}{h_{F_1} + P} \right] \right) - \deltaP \left(q_2  \left[ \frac{\beta_{F_1}P}{e_{F_1} + F_1} \right] \right) - \tau_{12}F_2 - d_{F_1}F_1]
$$

#+begin_src matlab :tangle growthODEs.m

    dydt(2,:) = F1 .* ((1 - deltaF1) * rF1 + cF1 * (deltaF1 * (alphaF1P .* P) ./ (hF1P + P)) - qF1 * (deltaP * ((betaF1 .* P) ./ (eF1 + F1))) - (tau12 .* F2) - (dF1 .* F1));
#+end_src

*** Species /F/, Phenotype 2

$$
\frac{dF_2}{dt} = F_2[(1 - \delta_{F_2})r_{F_2} + \delta_{F_2} \left(c_2 \left[\frac{\alpha_{F_2P}P}{h_{F_2} + P} \right] \right) - \deltaP \left(q_2  \left[ \frac{\beta_{F_2}P}{e_{F_2} + F_2} \right] \right) - \tau_{21}F_1 - d_{F_2}F_2]
$$

#+begin_src matlab :tangle growthODEs.m

    dydt(3,:) = F2 .* ((1 - deltaF2) * rF2 + cF2 * (deltaF2 * (alphaF2P .* P) ./ (hF2P + P)) - qF2 * (deltaP * ((betaF2 .* P) ./ (eF2 + F2))) - (tau21 .* F1) - (dF2 .* F2));

#+end_src

*** Reshape

#+begin_src matlab :tangle growthODEs.m

    dydt = reshape(dydt,3*nodes,1);
end

#+end_src

* Parameter sweep

** Sweep script

This is the main file to be edited when running parameter sweeps. The =simMutualism()= function requires an output directory as an argument. It can take any ODE parameter as an optional argument. to override a default value, use the parameter variable name then a value, i.e. =simMutualism(outputDir, 'tau12', 0.3, 'tau21', 0.14)=. These variables will get added to the filename of the exported mat file at the end of the simulation.

We can adjust values of =maxIterations= in the for loop to allow for longer simulations of $\tau$ values that we know will take longer to reach a steady state. By allow for more iterations for only these values, we limit the number of very large mat files.

#+begin_src matlab :tangle tauSweep.m

iterations = 100;
maxIterations = 1000;
[tau12Range, tau21Range] = deal(0:0.01:0.4);
outputDir = './tauSweep/';

for tau12 = tau12Range

    for tau21 = tau21Range

        % more iterations for tau values that result in regional coexistence
        if tau12 > 0.13 && tau12 < 0.3 && tau21 < 0.15 || tau21 > 0.3
            maxIterations = 2000;
        else
            maxIterations = 1000;
        end

        simMutualism(outputDir, 'tau12', tau12, 'tau21', tau21, 'iterations', iterations, 'maxIterations', maxIterations);

    end
end

#+end_src

#+begin_src shell :tangle no

#!/bin/bash

BASEDIR=~/sweep

ORIGFILE=$BASEDIR/mutual_comp_model.m
JOBSCRIPT=$BASEDIR/tau_jobscript.sh

chmod 775 $JOBSCRIPT

# create a directory to store all the .m and .mat files
mkdir -p $BASEDIR/{m_files,mat_files}

# create directories to store symlinks to the various figures
mkdir -p $BASEDIR/figures/{n_v_x,range,speed}/png

# create a directory to store each simulation
mkdir -p $BASEDIR/tau_sweep

# Loop through all the tau values you want to simulate
for comp21 in $(seq 0.0 0.01 0.4);
do
    for comp12 in $(seq 0.13 0.01 0.29);
    do

	# Format the comp12 and comp21 floating point values with the same format spec as the MATLAB files
	printf -v fcomp12 '%.2f' $comp12
	printf -v fcomp21 '%.2f' $comp21

        # Check to see if the current parameter value exists as a file (i.e. it's already been run on a previous sweep)
        # If it exists, skip it
        PARAMETERFILE=$BASEDIR/tau_sweep/mcm_comp21=${fcomp21}_comp12=${fcomp12}
        if [ -f "$PARAMETERFILE" ]; then
                continue
        else
                # create a directory to hold all files for each simulation
                mkdir -p $PARAMETERFILE

                # Replace the decimal values after comp_12 and comp_21 in the original .m file with the
                # current for loop values and create a new .m file with these values in the filename
                # then update .m file to save newly generated mat, fig, and png files to directory created above
sed -r "s/(comp_12\s*=\s*)[0-9]+\.?[0-9]*/\1${fcomp12}/; s/(comp_21\s*=\s*)[0-9]+\.?[0-9]*/\1${fcomp21}/; s/comp_pheno_model/tau_sweep\/mcm_comp21=${fcomp21}_comp12=${fcomp12}/" <$ORIGFILE >$BASEDIR/m_files/mcm_comp21=${fcomp21}_comp12=${fcomp12}.m


                chmod 775 $BASEDIR/m_files/mcm_comp21=${fcomp21}_comp12=${fcomp12}.m

                # Append instructions for the new .m file to the MSI batch job script


                # This updates the job script to use the current sim's values
                sed -i -r "s/(comp[_]?12=)[0-9]+\.?[0-9]*/\1${fcomp12}/g; s/(comp[_]?21=)[0-9]+\.?[0-9]*/\1${fcomp21}/g" $JOBSCRIPT

                sbatch $JOBSCRIPT
        fi
    done
done

#+end_src

** Slurm job script

Note that the $SBATCH lines *must* be at the top of the script. Anything before that will break Slurm.

#+begin_src shell :tangle jobscript.sh

#!/bin/bash -l
#SBATCH --time=24:00:00
#SBATCH --ntasks=16
#SBATCH --mem=20g
#SBATCH --tmp=20g
#SBATCH --mail-type=ALL
#SBATCH --mail-user=lutzx119@umn.edu

BASEDIR=~/mutualism
module load matlab
matlab -nodisplay <$BASEDIR/tauSweep.m

#+end_src

** Function to classify outcome (=det_outcome.m=)

#+begin_src matlab :tangle det_outcome.m

%% Function to classify outcome of a given simulation
function outcome = det_outcome(nP, nF1, nF2, nThreshold)

    % get the final population densities of P, F1, and F2
    finP = nP(end,:);
    finF1 = nF1(end,:);
    finF2 = nF2(end,:);

    % get the ranges where F1 and F2 populations are above the threshold
    rangeP = find(finP >= nThreshold);
    rangeF1 = find(finF1 >= nThreshold);
    rangeF2 = find(finF2 >= nThreshold);

    max_range = max(length(rangeF1), length(rangeF2));
    % max_range = size(rangeP);

    % if F2 is below the threshold across the total range, then classify as
    % F1 dominance
    if isempty(rangeF2)
        outcome = 1; % F1 dominance

    % if F1 is below the threshold across the total range, then classify as
    % F2 dominance
    elseif isempty(rangeF1)
        outcome = 2; % F2 dominance

    % elseif length(rangeF1)/max_range >= 0.95 & length(rangeF2)/max_range >= 0.95

    % find the range of values in rangeF1 or rangeF2 but not both
    % if the proportion of this range over the total range is less than
    % the arbitrary value 0.05, we call it local coexistence
    elseif length(setxor(rangeF1, rangeF2))/max_range < 0.05
        outcome = 3; % Local coexistence

    % if F1 is above threshold and F2 is below threshold or F2 is above
    % threshold and F1 is below threshold

    % elseif isempty(find(finF2(setxor(rangeF1, rangeF2)) >= nThreshold))

    % we find at least some F1 dominance
    elseif not(isempty(intersect(rangeF1, setxor(rangeF1, rangeF2))))

        % we find at least some F2 dominance
        if not(isempty(intersect(rangeF2, setxor(rangeF1, rangeF2))))
            outcome = 6; % regional coexistence

        % no F2 dominance
        else
            outcome = 4; % Local coexistence + F1 dominance
        end

    elseif not(isempty(intersect(rangeF2, setxor(rangeF1, rangeF2))))
        outcome = 5; % Local coexistence + F2 dominance

    else
        outcome = 7; % unknown
    end
end
#+end_src

* Figures

** 3D population density vs. space vs. time plots

These plots are helpful to see how the population densities change over time, but the 2D final spatial outcome plots are a little easier to read if all we care about is what happens at the steady state.

We generate a plot for each species, and they're superimposed in a single figure.

#+begin_src matlab :tangle plotPopSpaceTime.m

function plotPopSpaceTime(simMatFile, varargin)

    p = inputParser;
    addRequired(p, 'simMatFile', @isfile);
    addOptional(p,'createFile', false, @islogical);
    addOptional(p, 'imgDir', './', @isfolder);

    parse(p, simMatFile, varargin{:});

    load(simMatFile, 'filename', 'iterations', 'nP', 'nF1', 'nF2', 'nThreshold');

    %% Figure for species P
    figure(1);
    clf
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = nP;
    nlow(nP>=nThreshold) = NaN;
    nP(nP<nThreshold) = NaN;
    hold on
    for i = 1:5:60
        plot3(xx(i,:),tt(i,:),nP(i,:),'b', 'LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end
    % plot3(rangeEdgeP(1:11),0:10,nThreshold*ones(1,11),'k');
    axis([-120 120 0 iterations 0 6.25]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('density');
    % title('Species P');
    view(30,30);

    %% Figure for species F1
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = nF1;
    nlow(nF1>=nThreshold) = NaN;
    nF1(nF1<nThreshold) = NaN;
    hold on
    for i = 1:5:60
        plot3(xx(i,:),tt(i,:),nF1(i,:),'r','LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end

    % plot3(rangeEdgeF1(1:11),0:10,nThreshold*ones(1,11),'k');
    % axis([-15 15 0 10 0 5]);
    % xlabel('space (x)');
    % ylabel('time (t)');
    % zlabel('species F1 density (nF1)');
    % view(30,30);
    % title('Species F1');

    %% Figure for species F2
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = nF2;
    nlow(nF2>=nThreshold) = NaN;
    nF2(nF2<nThreshold) = NaN;
    hold on
    for i = 1:5:60
        plot3(xx(i,:),tt(i,:),nF2(i,:),'g', 'LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end

    % plot3(rangeEdgeF2(1:11),0:100,nThreshold*ones(1,11),'k');
    % axis([-15 15 0 10 0 5]);
    % xlabel('space (x)');
    % ylabel('time (t)');
    % zlabel('species F2 density (nF2)');
    % view(30,30);
    % title('Species F2');
    hold off

    if p.Results.createFile
        filename = strcat('pop_space_time_', filename, '.fig');
        savefig(strcat(imgDir, filename));
    end

end
#+end_src

** Speed vs. time

#+begin_src matlab :tangle plotSpeedTime.m

function plotSpeedTime(simMatFile, varargin)

    p = inputParser;
    addRequired(p, 'simMatFile', @isfile);
    addOptional(p,'createFile', false, @islogical);
    addOptional(p, 'imgDir', './', @isfolder);

    parse(p, simMatFile, varargin{:});

    load(simMatFile, 'filename', 'iterations', 'instantSpeedP', 'instantSpeedF1', 'instantSpeedF2');

    plot(1:iterations, instantSpeedP, 1:iterations, instantSpeedF1, 1:iterations, instantSpeedF2);
    legend('P', 'F1', 'F2');
    title(strcat(['Spread speed vs. time']));
    xlabel('iterations');
    ylabel('speed');

    if p.Results.createFile
        filename = strcat('speed_time_', filename, '.fig');
        savefig(strcat(imgDir, filename));
    end
end

#+end_src

** Final population densities across space

 #+begin_src matlab :tangle plotFinalPopSpace.m

function plotFinalPopSpace(simMatFile, varargin)

    p = inputParser;
    addRequired(p, 'simMatFile', @isfile);
    addOptional(p,'createFile', false, @islogical);
    addOptional(p, 'imgDir', './', @isfolder);

    parse(p, simMatFile, varargin{:});

    load(simMatFile, 'nP', 'nF1', 'nF2', 'iterations', 'filename');

    hold on
    plot(nP(iterations + 1,:));
    plot(nF1(iterations + 1,:));
    plot(nF2(iterations + 1,:));
    legend('P', 'F1', 'F2');
    title(strcat(['N vs. x']));
    hold off

    if p.Results.createFile
        filename = strcat('final_pop_space_', filename, '.fig');
        savefig(strcat(imgDir, filename));
    end
end
#+end_src

** Range vs. time

This plot shows how the overall range of each species changes over time.

In order to obtain the range of a species at a given time, you could find all the spatial points in the /n/ matrices (columns) where the value is greater than some minimum population. =nP= is a matrix with rows for each iteration and columns for each spatial point.

Does range size need to be contiguous? In other words, if F1 is only present at the edges, could you total its ranges at each edge and call that its "range size"?

#+begin_src matlab :tangle plotRangeTime.m

function plotRangeTime(simMatFile, varargin)

    p = inputParser;
    addRequired(p, 'simMatFile', @isfile);
    addOptional(p,'createFile', false, @islogical);
    addOptional(p, 'imgDir', './', @isfolder);


    parse(p, simMatFile, varargin{:});

    load(simMatFile, 'filename', 'nThreshold', 'nP', 'nF1', 'nF2', 'iterations');

    for i = 1:(iterations + 1)

        rangeP(i) = length(find(nP(i,:) >= nThreshold));
        rangeF1(i) = length(find(nF1(i,:) >= nThreshold));
        rangeF2(i) = length(find(nF2(i,:) >= nThreshold));
    end

    plot(1:(iterations + 1), [rangeP; rangeF1; rangeF2]);
    xlabel('iterations');
    ylabel('range size');
    title(strcat(['Range size vs. time']));
    legend('P', 'F1', 'F2');

    if p.Results.createFile
        filename = strcat('range_time_', filename, '.fig');
        savefig(strcat(imgDir, filename));
    end
end

#+end_src

** Populations vs. time plot


#+begin_src matlab :tangle pheno_pop_vs_time.m

% time span
tspan = 0.0:0.1:100.0;

% initial populations
initpop = [2.0; 2.0; 2.0];

r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];

nodes = 1;

[t,y] = ode45(@(t,y) growthODEs(t,y,r_p,r_f,alpha_pf,alpha_fp,q1,q2,beta1,beta2,c1,c2,d_p,d_f,h1,h2,e1,e2,nodes,dep_p,dep_f, comp_12, comp_21), tspan, initpop);

P = y(:,1);
F1 = y(:,2);
F2 = y(:,3);

% generate plot
figure;
plot(t, [P, F1, F2]);
legend('P', 'F1', 'F2');
xlabel('time');
ylabel('population');


#+end_src

** Phase space plot - P vs. F1 vs. F2 (=phenophase.m=)

In the two-species mutualism model, we took a range of possible starting population values (this is what we passed to the =meshgrid()= function to generate a matrix for each species). We then sent these matrices to our ODE function, which returned the growth rates for each combination of starting population values—this is how we got our vector field arrows.

*** Initial setup for 3D phase space plot

Here you generate the vector field with the =meshgrid()= and =quiver()= functions

#+begin_src matlab :tangle phenophase.m

maxpop = 10.0;
popRange = 0.0:0.5:maxpop;

[P, F1, F2] = meshgrid(popRange);

r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];
comp_12 = 1.0;
comp_21 = 4.0;

ystart = [P(:).'; F1(:).'; F2(:).'];
ystart = reshape(ystart, 3*length(ystart), 1);

dy = growthODEs(0, ystart, r_p, r_f, alpha_pf, alpha_fp, q1, q2, beta1, beta2, c1, c2, d_p, d_f, h1, h2, e1, e2, length(P(:).'), dep_p, dep_f, comp_12, comp_21);

dP = reshape(dy((1:3:end),:), length(P), length(P), length(P));
dF1 = reshape(dy((2:3:end),:), length(P), length(P), length(P));
dF2 = reshape(dy((3:3:end),:), length(P), length(P), length(P));

u = dP ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
v = dF1 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
w = dF2 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);

figure;
quiver3(P, F1, F2, u, v, w, 0.35);
xlabel('P');
ylabel('F1');
zlabel('F2');
hold on;

#+end_src

*** Plot isoclines

#+begin_src matlab :tangle phenophase.m

syms x y z
eq1 = ((1-dep_p).*r_p + dep_p .* (c1.*((alpha_pf(1).*y)./(h2(1)+y) + (alpha_pf(2).*z)./(h2(2)+z)))- ((dep_f(1)+dep_f(2))/2) .*(q1.*(beta1.*(y + z)./(e1+x)))-(d_p.*x));
eq2 = ((1-dep_f(1)).*r_f(1) + c2 .*(dep_f(1).*(alpha_fp(1).*x)./(h1(1)+x))-q2.*(dep_p.*((beta2(1).*x)./(e2(1)+y))) -(d_f(1).*y));
eq3 = ((1-dep_f(2)).*r_f(2) + c2 .*(dep_f(2).*(alpha_fp(2).*x)./(h1(2)+x))-q2.*(dep_p.*((beta2(2).*x)./(e2(2)+z))) -(d_f(2).*z));

fimplicit3(eq1, [0 maxpop]);
fimplicit3(eq2, [0 maxpop]);
fimplicit3(eq3, [0 maxpop]);

hold off;

#+end_src



** "Meta" graph (=sweep_outcomes.m=)

#+begin_src matlab :tangle sweep_outcomes.m

clear all

fspec = '%.2f';
tau12_list = [0.00:0.01:0.40];
tau21_list = [0.00:0.01:0.40];

outcomes = zeros(length(tau12_list), length(tau21_list));

for ii = 1:length(tau12_list)
    for jj = 1:length(tau21_list)

        load(strcat(['~/sweep/mat_files/comp_pheno_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=' num2str(tau12_list(ii), fspec) '_comp_21=' num2str(tau21_list(jj), fspec) '.mat']));

        outcomes(ii,jj) = det_outcome(nP, nF1, nF2, 0.05);

    end
end

figure(1)
heatmap(tau12_list, fliplr(tau21_list), rot90(outcomes));
xlabel('tau_{12}');
ylabel('tau_{21}');

#+end_src

* Results

** Table of results

=comp_12= is how F2 negatively impacts F1, and =comp_21= is how F1 negatively impacts F2 through competition.

| dep_f(1) | dep_f(2) | alpha21(1) | alpha21(2) | comp_12 | comp_21 | result  | dom. pheno |
|----------+----------+------------+------------+---------+---------+---------+------------|
|      0.1 |      0.9 |        0.5 |        0.5 |     0.5 |     0.4 | dom     | F1         |
|      0.1 |      0.9 |        0.5 |        0.5 |     0.2 |     0.1 | dom     | F1         |
|      0.1 |      0.9 |        0.5 |        0.5 |     0.1 |     0.2 | dom     | F2         |
|      0.1 |      0.9 |        0.5 |        0.5 |    0.01 |    0.02 | loc     | F2         |
|      0.5 |      0.9 |        0.5 |        0.5 |       1 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.8 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.5 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.4 |     2.3 | dom     | F2         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.4 |       1 | dom     | F2         |
|      0.6 |      0.9 |        0.5 |        0.5 |    0.08 |    0.04 | loc     | F1         |
|      0.6 |      0.9 |        0.5 |        0.5 |    0.08 |    0.03 | loc     | F2         |
|      0.7 |      0.9 |        0.5 |        0.5 |     0.1 |     0.2 | dom     | F2         |
|      0.7 |      0.9 |        0.5 |        0.5 |    0.01 |    0.02 | loc     | F2         |
|      0.9 |      0.6 |        0.5 |        0.5 |    0.08 |    0.04 | dom/loc | F1         |
|      0.9 |      0.6 |        0.5 |        0.7 |    0.08 |    0.04 | loc     | F1/F2      |
|      0.9 |      0.6 |        0.3 |        0.7 |    0.08 |    0.04 | dom/loc | F2         |
|      0.9 |      0.6 |        0.3 |        0.9 |    0.08 |    0.04 | dom/loc | F2         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.09 |    0.01 | dom     | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.07 |    0.01 | dom/loc | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.04 |    0.01 | dom/loc | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.04 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |    0.04 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |    0.07 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |     0.1 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |     0.4 | reg     | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |     0.4 | dom     | F2         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.06 | dom/loc | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.09 | dom/loc | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |     0.2 | reg     | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.03 | dom/loc | F1/F2      |

** Interpretation

If we plot the two competition factors F1 and F2, we can determine where we find local coexistence, regional coexistence, and dominance. What we found is not entirely what we expected (specifically in the upper right region), where the competition factors are equal.



*** Defining local and regional coexistence

/Regional coexistence/ could be defined as both phenotypes being completely dominant in a portion of the total range at steady state.

/Local coexistence/ occurs when both phenotypes occupy the majority of the total range together at steady state.

*** Do we need 𝛅?



** 𝛕 sweep results

*** Interesting plots

**** Regional coexistence

=tau12 = 0.21=

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.21_comp_21=0.23.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.22_comp_21=0.25.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.23_comp_21=0.12.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.23_comp_21=0.27.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.24_comp_21=0.29.png]]

=tau12 = 0.24=

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.25_comp_21=0.31.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.27_comp_21=0.36.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]

[[~/sweep2/figures/range/png/range_size_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]

[[~/sweep2/figures/speed/png/speed_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]


** Iterations issue

In order to see what happens in areas of regional coexistence over the long-term, we're attempting to run these simulations with 1000 iterations. Using the m file as-is, we get the error: ~Index in position 2 exceeds array bounds (must not exceed 65537)~

Clearly this is an issue with the number of nodes or the diameter. Space shouldn't change; it seems that in trying to increase the number of iterations you're increasing space somewhere.

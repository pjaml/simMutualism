#+title: Mutualism Project Code

* Simulation

Here we simulate the outcome of many iterations of growth-dispersal cycles in three mutualist species.

Make sure to clear everything before running a new simulation.

#+begin_src matlab :tangle simMutualism.m
clearvars
clc

function simMutualism(varargin)
#+end_src

** Parameters

*** Simulation parameters

The number of growth-dispersal cycles (i.e. iterations) will change based on whether a steady state is reached for all three species. A species reaches a steady state when the variance between the last 10 spread speed values is at or below some threshold.

So the number of iterations defined here is just the /minimum/ number of iterations that a simulation will run. We also set the maximum number of iterations, so even if a steady state isn't reached, the simulation will end after this many cycles.

We also define the number of additional iterations (=add_iterations=) to try before checking for steady state again.

#+begin_src matlab :tangle simMutualism.m
%% for simulation

iterations = 60; % cycles of growth and dispersal
steady_state_threshold = 1e-04; % threshold for speed variance at steady state
max_iterations = 500;
add_iterations = 100;

#+end_src

We set this =fspec= variable so that automatically generated filenames use a standardized format for values. This is necessary for the parameter sweep script to work properly.

#+begin_src matlab :tangle simMutualism.m
% format spec for floating point values in filenames
fspec = '%.2f';
#+end_src

*** Space parameters

Here we create the one-dimensional landscape in which the species will disperse.

=linspace(x1, x2, n)= creates a vector of =n= points between points =x1= and =x2=. Spacing between points is =(x2-x1)/(n-1)=. See [[https://in.mathworks.com/help/matlab/ref/linspace.html][linspace documentation]].

#+begin_comment
Why these specific values?

#+end_comment

#+begin_src matlab :tangle simMutualism.m

%% Initialize space parameters
lowval = 1e-9;
diameter = 1200;  %total size of landscape along positive x-axis (so technically half the size of the total landscape)
nodes = (2^16)+1; %total points in space -- 65537
radius = diameter/2;
x = linspace(-radius,radius,nodes);
x2 = linspace(-diameter,diameter,2*nodes-1);
dx = diameter/(nodes-1);
#+end_src

** Initialization

#+begin_src matlab :tangle simMutualism.m

[speed_inst_P,speed_av_P, speed_inst_F1,speed_av_F1, speed_inst_F2, speed_av_F2] = deal(zeros(1,iterations)); %assign initializing values to each of the arrays
[xright_P,xright_F1, xright_F2] = deal(zeros(1,iterations+1)); %array with 1 row and 201 columns. tells us the farthest a population has reached
[n_P,n_F1, n_F2] = deal(zeros(iterations+1,length(x))); %array with 201 rows and 65537 columns. tells us population density at each node along column and each time step/iteration is one row. define ,f_P_all,f_F_all if you wish to do post census calculations

#+end_src

*** Dispersal kernels

#+begin_src matlab :tangle simMutualism.m
sigma_sq = 0.25; % Dispersal variance

% gaussian dispersal kernels
k_P = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
k_F1 = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
k_F2 = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);

#+end_src

*** Initial population densities

#+begin_src matlab :tangle simMutualism.m
% SET THE INITIAL CONDITIONS
irad = 2; % Initial condition range
idens = [0.1,0.1,0.1];
ncrit = 0.05; % critical threshold for edge of wave
temp_P = find(abs(x) <= irad); %locate all values in the array x that lie b/w +irad and -irad units of space
temp_F1 = find(abs(x) <= irad);
temp_F2 = find(abs(x) <= irad);

n_P(1,temp_P) = idens(1)*normpdf(x(temp_P),0,1); %Computes pdf values evaluated at the values in x i.e. all x(temp) values for the normal distribution with mean 0 and standard deviation 1.
n_F1(1,temp_F1) = idens(2)*normpdf(x(temp_F1),0,1);
n_F2(1,temp_F2) = idens(3)*normpdf(x(temp_F2),0,1);

#+end_src

*** Initial front location

#+begin_src matlab :tangle simMutualism.m
% FIND THE INITIAL FRONT LOCATION
jj_P = find(n_P(1,:) >= ncrit,1,'last'); %find the farthest distance travelled by the population above a certain threshold density and assign it to jj
jj_F1 = find(n_F1(1,:) >= ncrit,1,'last');
jj_F2 = find(n_F2(1,:) >= ncrit,1,'last');

if jj_P %the initial front is obtained from initialization which will be in the first row of 'n'
  xright_P(1) = interp1(n_P(1,jj_P:jj_P+1),x(jj_P:jj_P+1),ncrit);
end
if jj_F1
  xright_F1(1) = interp1(n_F1(1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),ncrit);
end

if jj_F2
  xright_F2(1) = interp1(n_F2(1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),ncrit);
end

#+end_src

** Simulating growth and dispersal over many generations

#+begin_src matlab :tangle simMutualism.m
generation = 1;
%% Looping for growth and dispersal
while generation < iterations

    tspan = [0, 10];

    %Growth
    y0 = [n_P(generation,:);n_F1(generation,:);n_F2(generation,:)];

    % reshape happens such that 3 consecutive rows for n_P, n_F1, and n_F2 values are stacked
    y0 = reshape(y0, 3*length(y0), 1);

    [t,y] = ode45(@(t,y) growthODEs(t,y), tspan, y0); %remember to alter where the dep_p and dep_f are being called from


    % We just want the results of the growth phase (end)
    f_P = y(end,(1:3:end)); % final row; element 1, +3, elem. 4, etc. until end
    f_F1 = y(end,(2:3:end));
    f_F2 = y(end,(3:3:end));

%   DISPERSAL
    n1_P = fft_conv(k_P,f_P);   % dispersing individuals
    n1_F1 = fft_conv(k_F1,f_F1);
    n1_F2 = fft_conv(k_F2,f_F2);

    n_P(generation + 1,:) = dx*n1_P(nodes:length(x2)); %the convolution apparently doubles the length of the array?
    n_F1(generation + 1,:) = dx*n1_F1(nodes:length(x2));
    n_F2(generation + 1,:) = dx*n1_F2(nodes:length(x2));

    n_P(generation + 1,1) = n_P(generation + 1,1)/2; n_P(generation + 1,nodes) = n_P(generation + 1,nodes)/2; %The population density at the edges is halved
    n_F1(generation + 1,1) = n_F1(generation + 1,1)/2; n_F1(generation + 1,nodes) = n_F1(generation + 1,nodes)/2;
    n_F2(generation + 1,1) = n_F2(generation + 1,1)/2; n_F2(generation + 1,nodes) = n_F2(generation + 1,nodes)/2;

    temp_P = find(n_P(generation + 1,:) < lowval); %gives location of random places where numbers are above zero due to some numerical errors
    temp_F1 = find(n_F1(generation + 1,:) < lowval);
    temp_F2 = find(n_F2(generation + 1,:) < lowval);

    n_P(generation + 1,temp_P) = zeros(size(n_P(generation + 1,temp_P))); %set the places with those numerical errors to zero
    n_F1(generation + 1,temp_F1) = zeros(size(n_F1(generation + 1,temp_F1)));%delete this for STE
    n_F2(generation + 1,temp_F2) = zeros(size(n_F2(generation + 1,temp_F2)));%delete this for STE

    jj_P = find(n_P(generation + 1,:) >= ncrit,1,'last');
    jj_F1 = find(n_F1(generation + 1,:) >= ncrit,1,'last');
    jj_F2 = find(n_F2(generation + 1,:) >= ncrit,1,'last');

    if jj_P
         xright_P(generation + 1) = interp1(n_P(generation + 1,jj_P:jj_P + 1),x(jj_P:jj_P + 1),ncrit);
    end

    if jj_F1
         xright_F1(generation + 1) = interp1(n_F1(generation + 1,jj_F1:jj_F1 + 1),x(jj_F1:jj_F1 + 1),ncrit);
    end

    if jj_F2
         xright_F2(generation + 1) = interp1(n_F2(generation + 1,jj_F2:jj_F2 + 1),x(jj_F2:jj_F2 + 1),ncrit);
    end

    speed_av_P(generation) = (xright_P(generation + 1) - xright_P(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time
    speed_inst_P(generation) = xright_P(generation + 1) - xright_P(generation);

    speed_inst_F1(generation) = xright_F1(generation + 1) - xright_F1(generation);
    speed_av_F1(generation) = (xright_F1(generation + 1) - xright_F1(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time

    speed_inst_F2(generation) = xright_F2(generation + 1) - xright_F2(generation);
    speed_av_F2(generation) = (xright_F2(generation + 1) - xright_F2(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time

    % increment the while loop current iteration
    generation = generation + 1;

    %save(strcat(['mandm_yescost_depP=' num2str(dep_p) '_depF=' num2str(dep_f) '.mat']))
    %save mandm_nocost_yesdep.mat
% while loop end
end
#+end_src

** Dispersal phase function

#+begin_src matlab :tangle dispersal_phase.m

#+end_src

** Determining whether to continue running simulation based on steady states

#+begin_comment
What needs to be updated when adding more iterations? A few of the arrays are initialized depending on the number of iterations at the beginning of the for-loop, these need to be expanded. Would it be best to initialize them with larger arrays from the beginning, since resizing an array may be a costly operation?
#+end_comment

Logic needs to be if any species /is not/ at a steady state.

#+begin_src matlab :tangle no
    % Adds further iterations if steady states are not reached.
    if (i == iterations)


        % determine if all species at steady state
        if isSpeciesSteadyState(speed_inst_P, steady_state_threshold) || isSpeciesSteadyState(speed_inst_F1, steady_state_threshold) || isSpeciesSteadyState(speed_inst_F2, steady_state_threshold)

        end

            if iterations == (max_iterations - add_iterations)
                iterations = max_iterations;
            else
                iterations = iterations + 20;
            end

            % extend the sizes of the relevant vectors & matrices
            [speed_inst_P(length(speed_inst_P)+1:iterations), speed_av_P(length(speed_av_P)+1:iterations), speed_inst_F1(length(speed_inst_F1)+1:iterations), speed_av_F1(length(speed_av_F1)+1:iterations), speed_inst_F2(length(speed_inst_F2)+1:iterations), speed_av_F2(length(speed_av_F2)+1:iterations)] = deal(0);
            [xright_P(length(xright_P)+1:iterations+1),xright_F1(length(xright_F1)+1:iterations+1), xright_F2(length(xright_F2)+1:iterations+1)] = deal(0);

            [n_P(height(n_P)+1:iterations+1,:), n_F1(height(n_F1)+1:iterations+1,:), n_F2(height(n_F2)+1:iterations+1,:)] = deal(zeros((iterations+1)-height(n_P), length(n_P)));
        else
            break
        end
    end

#+end_src

*** Steady state functions

#+begin_src matlab :tangle checkSteadyStates.m

function steadyStates = checkSteadyStates()

#+end_src

This function takes the spread speed values for a given species and checks to see if the variance in the last 10 values is at or below a threshold to determine whether a steady state has been reached.

#+begin_src matlab :tangle isSpeciesSteadyState.m
function isSteadyState = isSpeciesSteadyState(speed, tolerance)
% takes a matrix of speed values and checks whether the variance in the last 10 values is at or below a threshold

    variance = sqrt(var(speed(end-9:end)));
    if variance <= tolerance
        isSteadyState = true;
    else
        isSteadState = false;
    end
end
#+end_src

** Generate and save a mat file for the simulation

We save our results to a mat file, which can then be used to generate figures, identify outcomes, etc.

#+begin_src matlab :tangle simMutualism.m
%% Save a mat file with the current parameter values
%save(strcat(['~/sweep2/mat_files/comp_pheno_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.mat']));
filename = ''

save(strcat(['~/sweep2/mat_files/comp_pheno_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.mat']));

% end of simMutualism function
end
#+end_src

* Growth Model

Here we define the growth of each species using a system of ODEs.

** System of Equations (=growthODEs.m=)

*** Function definition

+Note that now =r2=, =alpha12=, =alpha21=, =beta2=, =d2=, =h1=, =h2=, =e2=, and =dep_f= are /1x2/ vectors. The first value is for $F_1$, the second is for $F_2$ (e.g. =r2(1)= is $F_2$'s growth rate)+

With =varargin=, we can optionally use parameter values other than the defaults, e.g. =growthODEs(t, y, 'default_r_p', 0.4)=. We need to use an [[https://www.mathworks.com/help/matlab/ref/inputparser.html][inputParser]] to manage the function's parameters.

#+begin_src matlab :tangle growthODEs.m

% function dydt = growthODEs(t, y, r1, r2, alpha12, alpha21, q1, q2, beta1, beta2, c1, c2, d1, d2, h1, h2,e1, e2, nodes, dep_p, dep_f, comp_12, comp_21)
function dydt = growthODEs(t, y, varargin)

    checkParameters(varargin);
#+end_src

*** Default parameter values

We set our default parameter values here. If the parameter is not explicitly defined in the function call, then these default values are used.

#+begin_src matlab :tangle growthODEs.m

    %% Default ODE parameter values

    default_nodes = (2^16) + 1;

    % intrinsic growth
    default_r_p = 0.3;
    default_r_f1 = 0.3;
    default_r_f2 = 0.3;

    % mutualism benefits
    default_alpha_p_f1 = 0.5;
    default_alpha_p_f2 = 0.5;
    default_alpha_f1_p = 0.5;
    default_alpha_f2_p = 0.5;

    default_q_p = 1.0;
    default_q_f1 = 1.0;
    default_q_f2 = 1.0;

    % mutualism costs
    default_beta_p = 0.0;
    default_beta_f1 = 0.0;
    default_beta_f2 = 0.0;

    default_c_p = 1.0;
    default_c_f1 = 1.0;
    default_c_f2 = 1.0;

    % death rate
    default_d_p = 0.1;
    default_d_f1 = 0.1;
    default_d_f2 = 0.1;

    % saturation
    default_h_p_f1 = 0.3;
    default_h_p_f2 = 0.3;
    default_h_f1_p = 0.3;
    default_h_f2_p = 0.3;

    default_e_p = 0.3;
    default_e_f1 = 0.3;
    default_e_f2 = 0.3;

    % = 0.0;
    default_delta_p = 0.0;
    default_delta_f1 = 0.9;
    default_delta_f2 = 0.1;

    % competition: tau_12 is the effect F2 has on F1; tau_21 is effect of F1 on F2
    default_tau_12 = 0.0;
    default_tau_21 = 0.0;

#+end_src

*** Adding parameters with =inputParser=

See [[https://www.mathworks.com/help/matlab/ref/inputparser.html][inputParser]] and [[https://www.mathworks.com/help/matlab/ref/inputparser.addparameter.html][addParameter]] documentation. By setting =p.KeepUnmatched = true=, we can pass along all the parameters given in the simMutualism function call and just ignore the ones that are not relevant to the ODE parameters.

#+begin_src matlab :tangle growthODEs.m

    p = inputParser;
    p.KeepUnmatched = true;

    addRequired(p, 't');
    addRequired(p, 'y');

    %% Optional ODE parameters

    addParameter(p, 'nodes', default_nodes);

    % intrinsic growth rates
    addParameter(p, 'r_p', default_r_p);
    addParameter(p, 'r_f1', default_r_f1);
    addParameter(p, 'r_f2', default_r_f2);

    % mutualism benefits
    addParameter(p, 'alpha_p_f1', default_alpha_p_f1);
    addParameter(p, 'alpha_p_f2', default_alpha_p_f2);
    addParameter(p, 'alpha_f1_p', default_alpha_f1_p);
    addParameter(p, 'alpha_f2_p', default_alpha_f2_p);

    addParameter(p, 'q_p', default_q_p );
    addParameter(p, 'q_f1', default_q_f1);
    addParameter(p, 'q_f2', default_q_f2);

    % mutualism costs
    addParameter(p, 'beta_p', default_beta_p);
    addParameter(p, 'beta_f1', default_beta_f1);
    addParameter(p, 'beta_f2', default_beta_f2);

    addParameter(p, 'c_p', default_c_p);
    addParameter(p, 'c_f1', default_c_f1);
    addParameter(p, 'c_f2', default_c_f2);

    % death rate
    addParameter(p, 'd_p', default_d_p);
    addParameter(p, 'd_f1', default_d_f1);
    addParameter(p, 'd_f2', default_d_f2);

    % saturation
    addParameter(p, 'h_p_f1', default_h_p_f1);
    addParameter(p, 'h_p_f2', default_h_p_f2);
    addParameter(p, 'h_f1_p', default_h_f1_p);
    addParameter(p, 'h_f2_p', default_h_f2_p);

    addParameter(p, 'e_p', default_e_p);
    addParameter(p, 'e_f1', default_e_f1);
    addParameter(p, 'e_f2', default_e_f2);

    % mutualism dependence
    addParameter(p, 'delta_p', default_delta_p);
    addParameter(p, 'delta_f1', default_delta_f1);
    addParameter(p, 'delta_f2', default_delta_f2);

    % competition
    addParameter(p, 'tau_12', default_tau_12);
    addParameter(p, 'tau_21', default_tau_21);

    parse(p, t, y, varargin{:});

    % relabel variables so they're easier to read in the equation

    t = p.Results.t;
    y = p.Results.y;
    nodes = p.Results.nodes;

    % intrinsic growth
    r_p = p.Results.r_p;
    r_f1 = p.Results.r_f1;
    r_f2 = p.Results.r_f2;

    % mutualism benefits
    alpha_p_f1 = p.Results.alpha_p_f1;
    alpha_p_f2 = p.Results.alpha_p_f2;
    alpha_f1_p = p.Results.alpha_f1_p;
    alpha_f2_p = p.Results.alpha_f2_p;

    q_p = p.Results.q_p;
    q_f1 = p.Results.q_f1;
    q_f2 = p.Results.q_f2;

    % mutualism costs
    beta_p = p.Results.beta_p;
    beta_f1 = p.Results.beta_f1;
    beta_f2 = p.Results.beta_f2;

    c_p = p.Results.c_p;
    c_f1 = p.Results.c_f1;
    c_f2 = p.Results.c_f2;

    % death rate
    d_p = p.Results.d_p;
    d_f1 = p.Results.d_f1;
    d_f2 = p.Results.d_f2;

    % saturation
    h_p_f1 = p.Results.h_p_f1;
    h_p_f2 = p.Results.h_p_f2;
    h_f1_p = p.Results.h_f1_p;
    h_f2_p = p.Results.h_f2_p;

    e_p = p.Results.e_p;
    e_f1 = p.Results.e_f1;
    e_f2 = p.Results.e_f2;

    % mutualism dependence
    delta_p = p.Results.delta_p;
    delta_f1 = p.Results.delta_f1;
    delta_f2 = p.Results.delta_f2;

    % competition: tau_12 is the effect F2 has on F1; tau_21 is effect of F1 on F2
    tau_12 = p.Results.tau_12;
    tau_21 = p.Results.tau_21;

    y = reshape(y,3,nodes);
    dydt  = zeros(size(y));


#+end_src

*** Species /P/

# Equation broken in HTML export

$$
\frac{dP}{dt} = P\left[ (1 - \delta_P) r_P + \delta_P \left( c_1 \left[\frac{\alpha_{PF_1} F_1}{h_P_1 + F_1}  + \frac{\alpha_{PF_2} F_2}{h_P_2 + F_2} \right] \right) - \left(\frac{\delta_{F1} + \delta_{F2}}{2} \right) \left( q_1 \left[ \frac{\beta_{PF} (F_1 + F_2)}{e_P + P} \right] \right) - d_P P \right]
$$

The $(\delta_{F1} + \delta_{F2} / 2)$ term should be changed. It's currently irrelevant since we've only used $\beta$ values of zero.

#+begin_src matlab :tangle growthODEs.m

    % rename variables so equations are easier to read
    P = y(1,:);
    F1 = y(2,:);
    F2 = y(3,:);

    dydt(1,:) = P .* ((1 - delta_p) * r_p + delta_p * (c_p * ((alpha_p_f1 .* F1) ./ (h_p_f1 + F1) + (alpha_p_f2 .* F2) ./ (h_p_f2 + F2))) - ((delta_f1 + delta_f2)/2) * (q_p * (beta_p .* (F1 + F2) ./ (e_p + P))) - (d_p .* P));

#+end_src

*** Species /F/, Phenotype 1

$$
\frac{dF_1}{dt} = F_1[(1 - \delta_{F_1})r_{F_1} + \delta_{F_1} \left( c_2 \left[\frac{\alpha_{F_1P}P}{h_{F_1} + P} \right] \right) - \delta_P \left(q_2  \left[ \frac{\beta_{F_1P}P}{e_{F_1} + F_1} \right] \right) - \tau_{12}F_2 - d_{F_1}F_1]
$$

#+begin_src matlab :tangle growthODEs.m

    dydt(2,:) = F1 .* ((1 - delta_f1) * r_f1 + c_f1 * (delta_f1 * (alpha_f1_p .* P) ./ (h_f1_p + P)) - q_f1 * (delta_p * ((beta_f1 .* P) ./ (e_f1 + F1))) - (tau_12 .* F2) - (d_f1 .* F1));
#+end_src

*** Species /F/, Phenotype 2

$$
\frac{dF_2}{dt} = F_2[(1 - \delta_{F_2})r_{F_2} + \delta_{F_2} \left(c_2 \left[\frac{\alpha_{F_2P}P}{h_{F_2} + P} \right] \right) - \delta_P \left(q_2  \left[ \frac{\beta_{F_2P}P}{e_{F_2} + F_2} \right] \right) - \tau_{21}F_1 - d_{F_2}F_2]
$$

#+begin_src matlab :tangle growthODEs.m

    dydt(3,:) = F2 .* ((1 - delta_f2) * r_f2 + c_f2 * (delta_f2 * (alpha_f2_p .* P) ./ (h_f2_p + P)) - q_f2 * (delta_p * ((beta_f2 .* P) ./ (e_f2 + F2))) - (tau_21 .* F1) - (d_f2 .* F2));

#+end_src

*** Reshape

#+begin_src matlab :tangle growthODEs.m

    dydt = reshape(dydt,3*nodes,1);
end

#+end_src

* Parameter sweep

** Sweep script

#+begin_src shell :tangle sweep/tau_sweep.sh

#!/bin/bash

BASEDIR=~/sweep

ORIGFILE=$BASEDIR/mutual_comp_model.m
JOBSCRIPT=$BASEDIR/tau_jobscript.sh

chmod 775 $JOBSCRIPT

# create a directory to store all the .m and .mat files
mkdir -p $BASEDIR/{m_files,mat_files}

# create directories to store symlinks to the various figures
mkdir -p $BASEDIR/figures/{n_v_x,range,speed}/png

# create a directory to store each simulation
mkdir -p $BASEDIR/tau_sweep

# Loop through all the tau values you want to simulate
for comp21 in $(seq 0.0 0.01 0.4);
do
    for comp12 in $(seq 0.13 0.01 0.29);
    do

	# Format the comp12 and comp21 floating point values with the same format spec as the MATLAB files
	printf -v fcomp12 '%.2f' $comp12
	printf -v fcomp21 '%.2f' $comp21

        # Check to see if the current parameter value exists as a file (i.e. it's already been run on a previous sweep)
        # If it exists, skip it
        PARAMETERFILE=$BASEDIR/tau_sweep/mcm_comp21=${fcomp21}_comp12=${fcomp12}
        if [ -f "$PARAMETERFILE" ]; then
                continue
        else
                # create a directory to hold all files for each simulation
                mkdir -p $PARAMETERFILE

                # Replace the decimal values after comp_12 and comp_21 in the original .m file with the
                # current for loop values and create a new .m file with these values in the filename
                # then update .m file to save newly generated mat, fig, and png files to directory created above
sed -r "s/(comp_12\s*=\s*)[0-9]+\.?[0-9]*/\1${fcomp12}/; s/(comp_21\s*=\s*)[0-9]+\.?[0-9]*/\1${fcomp21}/; s/comp_pheno_model/tau_sweep\/mcm_comp21=${fcomp21}_comp12=${fcomp12}/" <$ORIGFILE >$BASEDIR/m_files/mcm_comp21=${fcomp21}_comp12=${fcomp12}.m


                chmod 775 $BASEDIR/m_files/mcm_comp21=${fcomp21}_comp12=${fcomp12}.m

                # Append instructions for the new .m file to the MSI batch job script


                # This updates the job script to use the current sim's values
                sed -i -r "s/(comp[_]?12=)[0-9]+\.?[0-9]*/\1${fcomp12}/g; s/(comp[_]?21=)[0-9]+\.?[0-9]*/\1${fcomp21}/g" $JOBSCRIPT

                sbatch $JOBSCRIPT
        fi
    done
done

#+end_src

** Slurm job script

Note that the $SBATCH lines *must* be at the top of the script. Anything before that will break Slurm.

#+begin_src shell :tangle sweep/tau_jobscript.sh

#!/bin/bash -l
#SBATCH --time=24:00:00
#SBATCH --ntasks=16
#SBATCH --mem=20g
#SBATCH --tmp=20g
#SBATCH --mail-type=NONE
#SBATCH --mail-user=lutzx119@umn.edu

BASEDIR=~/sweep
module load matlab
matlab -nodisplay -nodesktop -nosplash -r "maxNumCompThreads(1)"<$BASEDIR/m_files/mcm_comp21=0.40_comp12=0.40.m

# create a link to this sim's mat file in the mat_files directory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/comp_pheno_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.mat mat_files/.

# create a link to this sim's range plot in the figures/range directory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/range_size_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.fig figures/range/.
# put the png file in the png subdirectory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/range_size_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.png figures/range/png/.

# create a link to this sim's N vs x plot in the figures/n_v_x directory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.fig figures/n_v_x/.
# put the png file in the png subdirectory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.png figures/n_v_x/png/.

# create a link to this sim's speed plot in the figures/speed directory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/speed_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.fig figures/speed/.
# put the png file in the png subdirectory
ln -s $BASEDIR/tau_sweep/mcm_comp21=0.40_comp12=0.40/speed_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.40_comp_21=0.40.png figures/speed/png/.

#+end_src

** Function to classify outcome (=det_outcome.m=)

#+begin_src matlab :tangle det_outcome.m

%% Function to classify outcome of a given simulation
function outcome = det_outcome(n_P, n_F1, n_F2, ncrit)

    % get the final population densities of P, F1, and F2
    fin_P = n_P(end,:);
    fin_F1 = n_F1(end,:);
    fin_F2 = n_F2(end,:);

    % get the ranges where F1 and F2 populations are above the threshold
    rangeP = find(fin_P >= ncrit);
    rangeF1 = find(fin_F1 >= ncrit);
    rangeF2 = find(fin_F2 >= ncrit);

    max_range = max(length(rangeF1), length(rangeF2));
    % max_range = size(rangeP);

    % if F2 is below the threshold across the total range, then classify as
    % F1 dominance
    if isempty(rangeF2)
        outcome = 1; % F1 dominance

    % if F1 is below the threshold across the total range, then classify as
    % F2 dominance
    elseif isempty(rangeF1)
        outcome = 2; % F2 dominance

    % elseif length(rangeF1)/max_range >= 0.95 & length(rangeF2)/max_range >= 0.95

    % find the range of values in rangeF1 or rangeF2 but not both
    % if the proportion of this range over the total range is less than
    % the arbitrary value 0.05, we call it local coexistence
    elseif length(setxor(rangeF1, rangeF2))/max_range < 0.05
        outcome = 3; % Local coexistence

    % if F1 is above threshold and F2 is below threshold or F2 is above
    % threshold and F1 is below threshold

    % elseif isempty(find(fin_F2(setxor(rangeF1, rangeF2)) >= ncrit))

    % we find at least some F1 dominance
    elseif not(isempty(intersect(rangeF1, setxor(rangeF1, rangeF2))))

        % we find at least some F2 dominance
        if not(isempty(intersect(rangeF2, setxor(rangeF1, rangeF2))))
            outcome = 6; % regional coexistence

        % no F2 dominance
        else
            outcome = 4; % Local coexistence + F1 dominance
        end

    elseif not(isempty(intersect(rangeF2, setxor(rangeF1, rangeF2))))
        outcome = 5; % Local coexistence + F2 dominance

    else
        outcome = 7; % unknown
    end
end
#+end_src

* Figures

** 3D population density vs. space vs. time plots

These plots are helpful to see how the population densities change over time, but the 2D final spatial outcome plots are a little easier to read if all we care about is what happens at the steady state.

We generate a plot for each species, and they're superimposed in a single figure.

#+begin_src matlab :tangle plotPopSpaceTime.m

function plotPopSpaceTime(simMatFile)

    load(simMatFile);

    %% Figure for species P
    figure(1);
    clf
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = n_P;
    nlow(n_P>=ncrit) = NaN;
    n_P(n_P<ncrit) = NaN;
    hold on
    for i = 1:5:60
        plot3(xx(i,:),tt(i,:),n_P(i,:),'b', 'LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end
    % plot3(xright_P(1:11),0:10,ncrit*ones(1,11),'k');
    axis([-120 120 0 iterations 0 6.25]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('density');
    % title('Species P');
    view(30,30);

    %% Figure for species F1
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = n_F1;
    nlow(n_F1>=ncrit) = NaN;
    n_F1(n_F1<ncrit) = NaN;
    hold on
    for i = 1:5:60
        plot3(xx(i,:),tt(i,:),n_F1(i,:),'r','LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end

    % plot3(xright_F1(1:11),0:10,ncrit*ones(1,11),'k');
    % axis([-15 15 0 10 0 5]);
    % xlabel('space (x)');
    % ylabel('time (t)');
    % zlabel('species F1 density (n_F1)');
    % view(30,30);
    % title('Species F1');

    %% Figure for species F2
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = n_F2;
    nlow(n_F2>=ncrit) = NaN;
    n_F2(n_F2<ncrit) = NaN;
    hold on
    for i = 1:5:60
        plot3(xx(i,:),tt(i,:),n_F2(i,:),'g', 'LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end

    % plot3(xright_F2(1:11),0:100,ncrit*ones(1,11),'k');
    % axis([-15 15 0 10 0 5]);
    % xlabel('space (x)');
    % ylabel('time (t)');
    % zlabel('species F2 density (n_F2)');
    % view(30,30);
    % title('Species F2');
    hold off

end
#+end_src

** Speed vs. time

#+begin_src matlab :tangle plotSpeedTime.m

function plotSpeedTime(simMatFile)

    load(simMatFile);

    clf

    plot(1:iterations, speed_inst_P, 1:iterations, speed_inst_F1, 1:iterations, speed_inst_F2);
    legend('P', 'F1', 'F2');
    title(strcat(['Spread speed vs. time (tau21=' num2str(comp_21) ', tau12=' num2str(comp_12) ')']));
    xlabel('iterations');
    ylabel('speed');

    savefig(strcat(['comp_pheno_model/speed_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.fig']));

end

#+end_src

** N spatial distribution

Three save functions are called:
- =save()= saves the current parameter values in a =.mat= file (with relevant parameter values in the filename)
- =savefig()= saves the matlab figure so we can easily view and manipulate it in matlab
- =saveas()= saves the figure as a PNG

 #+begin_src matlab :tangle plotFinalPopSpace.m

function plotFinalPopSpace(simMatFile)

    load(simMatFile);

    clf
    hold on
    plot(n_P(end,:));
    plot(n_F1(end,:));
    plot(n_F2(end,:));
    legend('P', 'F1', 'F2');
    title(strcat(['N vs. x (tau21=' num2str(comp_21) ', tau12=' num2str(comp_12) ')']));
    hold off

    savefig(strcat(['comp_pheno_model/N_v_x_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.fig']));

    % Save a PNG file
    % saveas(gcf, strcat(['comp_pheno_model/comp_pheno_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.png']));
end
#+end_src

** Range vs. time

This plot shows how the overall range of each species changes over time.

In order to obtain the range of a species at a given time, you could find all the spatial points in the /n/ matrices (columns) where the value is greater than some minimum population. =n_P= is a matrix with rows for each iteration and columns for each spatial point.

Does range size need to be contiguous? In other words, if F1 is only present at the edges, could you total its ranges at each edge and call that its "range size"?

#+begin_src matlab :tangle plotRangeTime.m

function plotRangeTime(simMatFile)

    load(simMatFile);
    for i = 1:iterations+1

        rangeP(i) = length(find(n_P(i,:) >= ncrit));
        rangeF1(i) = length(find(n_F1(i,:) >= ncrit));
        rangeF2(i) = length(find(n_F2(i,:) >= ncrit));
    end

    clf
    plot(1:iterations+1, [rangeP; rangeF1; rangeF2]);
    xlabel('iterations');
    ylabel('range size');
    title(strcat(['Range size vs. time (tau21=' num2str(comp_21) ', tau12=' num2str(comp_12) ')']));
    legend('P', 'F1', 'F2');

    savefig(strcat(['comp_pheno_model/range_size_depF1=' num2str(dep_f(1)) '_depF2=' num2str(dep_f(2)) '_alphaF1=' num2str(alpha_fp(1)) '_alphaF2=' num2str(alpha_fp(2)) '_comp_12=' num2str(comp_12, fspec) '_comp_21=' num2str(comp_21, fspec) '.fig']));

end

#+end_src

** Populations vs. time plot (=pheno_pop_vs_time.m=)

#+begin_src matlab :tangle pheno_pop_vs_time.m

% time span
tspan = 0.0:0.1:100.0;

% initial populations
initpop = [2.0; 2.0; 2.0];

r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];

nodes = 1;

[t,y] = ode45(@(t,y) growthODEs(t,y,r_p,r_f,alpha_pf,alpha_fp,q1,q2,beta1,beta2,c1,c2,d_p,d_f,h1,h2,e1,e2,nodes,dep_p,dep_f, comp_12, comp_21), tspan, initpop);

P = y(:,1);
F1 = y(:,2);
F2 = y(:,3);

% generate plot
figure;
plot(t, [P, F1, F2]);
legend('P', 'F1', 'F2');
xlabel('time');
ylabel('population');


#+end_src

** Phase space plot - P vs. F1 vs. F2 (=phenophase.m=)

In the two-species mutualism model, we took a range of possible starting population values (this is what we passed to the =meshgrid()= function to generate a matrix for each species). We then sent these matrices to our ODE function, which returned the growth rates for each combination of starting population values—this is how we got our vector field arrows.

*** Initial setup for 3D phase space plot

Here you generate the vector field with the =meshgrid()= and =quiver()= functions

#+begin_src matlab :tangle phenophase.m

maxpop = 10.0;
popRange = 0.0:0.5:maxpop;

[P, F1, F2] = meshgrid(popRange);

r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];
comp_12 = 1.0;
comp_21 = 4.0;

ystart = [P(:).'; F1(:).'; F2(:).'];
ystart = reshape(ystart, 3*length(ystart), 1);

dy = growthODEs(0, ystart, r_p, r_f, alpha_pf, alpha_fp, q1, q2, beta1, beta2, c1, c2, d_p, d_f, h1, h2, e1, e2, length(P(:).'), dep_p, dep_f, comp_12, comp_21);

dP = reshape(dy((1:3:end),:), length(P), length(P), length(P));
dF1 = reshape(dy((2:3:end),:), length(P), length(P), length(P));
dF2 = reshape(dy((3:3:end),:), length(P), length(P), length(P));

u = dP ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
v = dF1 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
w = dF2 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);

figure;
quiver3(P, F1, F2, u, v, w, 0.35);
xlabel('P');
ylabel('F1');
zlabel('F2');
hold on;

#+end_src

*** Plot isoclines

#+begin_src matlab :tangle phenophase.m

syms x y z
eq1 = ((1-dep_p).*r_p + dep_p .* (c1.*((alpha_pf(1).*y)./(h2(1)+y) + (alpha_pf(2).*z)./(h2(2)+z)))- ((dep_f(1)+dep_f(2))/2) .*(q1.*(beta1.*(y + z)./(e1+x)))-(d_p.*x));
eq2 = ((1-dep_f(1)).*r_f(1) + c2 .*(dep_f(1).*(alpha_fp(1).*x)./(h1(1)+x))-q2.*(dep_p.*((beta2(1).*x)./(e2(1)+y))) -(d_f(1).*y));
eq3 = ((1-dep_f(2)).*r_f(2) + c2 .*(dep_f(2).*(alpha_fp(2).*x)./(h1(2)+x))-q2.*(dep_p.*((beta2(2).*x)./(e2(2)+z))) -(d_f(2).*z));

fimplicit3(eq1, [0 maxpop]);
fimplicit3(eq2, [0 maxpop]);
fimplicit3(eq3, [0 maxpop]);

hold off;

#+end_src



** "Meta" graph (=sweep_outcomes.m=)

#+begin_src matlab :tangle sweep_outcomes.m

clear all

fspec = '%.2f';
tau_12_list = [0.00:0.01:0.40];
tau_21_list = [0.00:0.01:0.40];

outcomes = zeros(length(tau_12_list), length(tau_21_list));

for ii = 1:length(tau_12_list)
    for jj = 1:length(tau_21_list)

        load(strcat(['~/sweep/mat_files/comp_pheno_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=' num2str(tau_12_list(ii), fspec) '_comp_21=' num2str(tau_21_list(jj), fspec) '.mat']));

        outcomes(ii,jj) = det_outcome(n_P, n_F1, n_F2, 0.05);

    end
end

figure(1)
heatmap(tau_12_list, fliplr(tau_21_list), rot90(outcomes));
xlabel('tau_{12}');
ylabel('tau_{21}');

#+end_src

* Results

** Table of results

=comp_12= is how F2 negatively impacts F1, and =comp_21= is how F1 negatively impacts F2 through competition.

| dep_f(1) | dep_f(2) | alpha21(1) | alpha21(2) | comp_12 | comp_21 | result  | dom. pheno |
|----------+----------+------------+------------+---------+---------+---------+------------|
|      0.1 |      0.9 |        0.5 |        0.5 |     0.5 |     0.4 | dom     | F1         |
|      0.1 |      0.9 |        0.5 |        0.5 |     0.2 |     0.1 | dom     | F1         |
|      0.1 |      0.9 |        0.5 |        0.5 |     0.1 |     0.2 | dom     | F2         |
|      0.1 |      0.9 |        0.5 |        0.5 |    0.01 |    0.02 | loc     | F2         |
|      0.5 |      0.9 |        0.5 |        0.5 |       1 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.8 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.5 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.4 |     2.3 | dom     | F2         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.4 |       1 | dom     | F2         |
|      0.6 |      0.9 |        0.5 |        0.5 |    0.08 |    0.04 | loc     | F1         |
|      0.6 |      0.9 |        0.5 |        0.5 |    0.08 |    0.03 | loc     | F2         |
|      0.7 |      0.9 |        0.5 |        0.5 |     0.1 |     0.2 | dom     | F2         |
|      0.7 |      0.9 |        0.5 |        0.5 |    0.01 |    0.02 | loc     | F2         |
|      0.9 |      0.6 |        0.5 |        0.5 |    0.08 |    0.04 | dom/loc | F1         |
|      0.9 |      0.6 |        0.5 |        0.7 |    0.08 |    0.04 | loc     | F1/F2      |
|      0.9 |      0.6 |        0.3 |        0.7 |    0.08 |    0.04 | dom/loc | F2         |
|      0.9 |      0.6 |        0.3 |        0.9 |    0.08 |    0.04 | dom/loc | F2         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.09 |    0.01 | dom     | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.07 |    0.01 | dom/loc | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.04 |    0.01 | dom/loc | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.04 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |    0.04 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |    0.07 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |     0.1 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |     0.4 | reg     | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |     0.4 | dom     | F2         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.06 | dom/loc | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.09 | dom/loc | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |     0.2 | reg     | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.03 | dom/loc | F1/F2      |

** Interpretation

If we plot the two competition factors F1 and F2, we can determine where we find local coexistence, regional coexistence, and dominance. What we found is not entirely what we expected (specifically in the upper right region), where the competition factors are equal.



*** Defining local and regional coexistence

/Regional coexistence/ could be defined as both phenotypes being completely dominant in a portion of the total range at steady state.

/Local coexistence/ occurs when both phenotypes occupy the majority of the total range together at steady state.

*** Do we need 𝛅?



** 𝛕 sweep results

*** Interesting plots

**** Regional coexistence

=tau12 = 0.21=

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.21_comp_21=0.23.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.22_comp_21=0.25.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.23_comp_21=0.12.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.23_comp_21=0.27.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.24_comp_21=0.29.png]]

=tau12 = 0.24=

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.25_comp_21=0.31.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.27_comp_21=0.36.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]

[[~/sweep2/figures/range/png/range_size_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]

[[~/sweep2/figures/speed/png/speed_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]


** Iterations issue

In order to see what happens in areas of regional coexistence over the long-term, we're attempting to run these simulations with 1000 iterations. Using the m file as-is, we get the error: ~Index in position 2 exceeds array bounds (must not exceed 65537)~

Clearly this is an issue with the number of nodes or the diameter. Space shouldn't change; it seems that in trying to increase the number of iterations you're increasing space somewhere.

:PROPERTIES:
:header-args: :comments link
:END:
#+title: Mutualism Project Code

* Simulation

Here we simulate the outcome of many generations of growth-dispersal cycles for three mutualist species. The =simMutualism()= function can take a number of optional arguments.

#+begin_src matlab :tangle simMutualism.m
function simMutualism(varargin)

% we save the given parameters to a variable so we can use them to
% name files and label plots
parameters = varargin;
#+end_src

** Parameters

*** Simulation parameters

The number of growth-dispersal cycles (i.e. iterations) will change based on whether a steady state is reached for all three species. A species reaches a steady state when the variance between the last 10 spread speed values is at or below some threshold.

So the number of iterations defined here is just the /minimum/ number of iterations that a simulation will run. We also set the maximum number of iterations, so even if a steady state isn't reached, the simulation will end after this many cycles. This value is also used to allocate space in a number of arrays used in the simulation. It's faster (although more costly in memory) to preallocate the maximum number of rows we may need to use, rather than to try and increase the size of several large arrays.

We also define the number of additional iterations (=iterationStep=) to add to the simulation before checking for steady states again.

#+begin_comment
Right now, all the optional parameters given to =simMutualism= are passed along to the =growthODEs= function. I'm not sure this matters, but it's possible that you could pass just =p.Unmatched= to =growthODEs= to make the code a little safer and more efficient.

It would be difficult though, since p.Unmatched
#+end_comment

#+begin_src matlab :tangle simMutualism.m
%% for simulation

p = inputParser;
p.KeepUnmatched = true;

% minimum number of cycles of growth and dispersal
addParameter(p, 'iterations', 100, @isnumeric);
addParameter(p, 'maxIterations', 480, @isnumeric);
addParameter(p, 'iterationStep', 100, @isnumeric);
addParameter(p, 'outputDir', './', @isfolder);
addParameter(p, 'steadyStateThreshold', 1e-04, @isnumeric);
addParameter(p, 'diameter', 1200, @isnumeric);

parse(p, varargin{:});

% I wish I knew a better way to get rid of all the p.Results that get attached inputParser parameters
iterations = p.Results.iterations;
maxIterations = p.Results.maxIterations;

if iterations > maxIterations
    disp("Warning: the value of iterations is greater than or equal to maxIterations, so maxIterations has been increased.");
    maxIterations = iterations;
end

iterationStep = p.Results.iterationStep;
outputDir = p.Results.outputDir;
steadyStateThreshold = p.Results.steadyStateThreshold;

%total size of landscape along positive x-axis (so half the total landscape)
diameter = p.Results.diameter;

if maxIterations > 490
    diameter = 3600;
    disp("Warning: maxIterations > 490 risks exceeding the spatial landscape boundaries. The diameter of the landscape has been increased to 3600. The spatial resolution has NOT been increased.");
end
#+end_src

*** Space parameters

Here we create the one-dimensional landscape in which the species will disperse.

=linspace(x1, x2, n)= creates a vector of =n= points between points =x1= and =x2=. Spacing between points is =(x2-x1)/(n-1)=. See [[https://in.mathworks.com/help/matlab/ref/linspace.html][linspace documentation]].

#+begin_comment
Why these specific values?

#+end_comment

#+begin_src matlab :tangle simMutualism.m
%% Initialize space parameters
lowval = 1e-9;
nodes = (2^16) + 1; %total points in space -- 65537
radius = diameter / 2;
x = linspace(-radius, radius, nodes);
x2 = linspace(-diameter, diameter, 2 * nodes - 1);
dx = diameter / (nodes - 1);
#+end_src

** Initialization

Here we initialize the arrays we'll use throughout the simulation. The speed arrays save the instantaneous or average spread speed of a species for each iteration. The range edge arrays keep track of the furthest spatial location on one side of a species' range. The /n/ population arrays keep track of each species' population density across the entire spatial range.

#+begin_src matlab :tangle simMutualism.m
[instantSpeedP, avgSpeedP, instantSpeedF1, avgSpeedF1, instantSpeedF2, avgSpeedF2] = deal(zeros(1, maxIterations + 1)); % preallocate arrays for max possible iterations + 1

[rangeEdgeP,rangeEdgeF1, rangeEdgeF2] = deal(zeros(1, maxIterations + 1));

[nP, nF1, nF2] = deal(zeros(maxIterations + 1, length(x)));
#+end_src

*** Dispersal kernels

We use a Gaussian dispersal kernel for each species. At some point we'll rewrite this to allow for other dispersal kernel functions.

#+begin_src matlab :tangle simMutualism.m
sigma_sq = 0.25; % Dispersal variance

% gaussian dispersal kernels
kP = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
kF1 = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
kF2 = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq);
#+end_src

*** Initial population densities

We set the initial population densities across the spatial range.

#+begin_src matlab :tangle simMutualism.m
% SET THE INITIAL CONDITIONS
irad = 2; % Initial condition range
initDensities = [0.1,0.1,0.1];
nThreshold = 0.05; % critical threshold for edge of wave
temp_P = find(abs(x) <= irad); %locate all values in the array x that lie b/w +irad and -irad units of space
temp_F1 = find(abs(x) <= irad);
temp_F2 = find(abs(x) <= irad);

nP(1,temp_P) = initDensities(1) * normpdf(x(temp_P),0,1); %Computes pdf values evaluated at the values in x i.e. all x(temp) values for the normal distribution with mean 0 and standard deviation 1.
nF1(1,temp_F1) = initDensities(2) * normpdf(x(temp_F1),0,1);
nF2(1,temp_F2) = initDensities(3) * normpdf(x(temp_F2),0,1);
#+end_src

*** Initial front location

#+begin_src matlab :tangle simMutualism.m
% FIND THE INITIAL FRONT LOCATION
jj_P = find(nP(1,:) >= nThreshold,1,'last'); %find the farthest distance travelled by the population above a certain threshold density and assign it to jj
jj_F1 = find(nF1(1,:) >= nThreshold,1,'last');
jj_F2 = find(nF2(1,:) >= nThreshold,1,'last');

if jj_P %the initial front is obtained from initialization which will be in the first row of 'n'
  rangeEdgeP(1) = interp1(nP(1,jj_P:jj_P+1),x(jj_P:jj_P+1),nThreshold);
end
if jj_F1
  rangeEdgeF1(1) = interp1(nF1(1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),nThreshold);
end

if jj_F2
  rangeEdgeF2(1) = interp1(nF2(1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),nThreshold);
end
#+end_src

** Simulating growth and dispersal over many generations

#+begin_src matlab :tangle simMutualism.m
generation = 1;
%% Looping for growth and dispersal
while generation <= iterations
#+end_src

*** Growth phase

#+begin_src matlab :tangle simMutualism.m
    % for ode45
    tspan = [0, 10];

    %Growth
    y0 = [nP(generation,:);nF1(generation,:);nF2(generation,:)];

    % reshape happens such that 3 consecutive rows for nP, nF1, and nF2 values are stacked
    y0 = reshape(y0, 3*length(y0), 1);

    [t,y] = ode45(@(t,y) growthODEs(t,y, varargin{:}), tspan, y0); %remember to alter where the dep_p and dep_f are being called from


    % We just want the results of the growth phase (end)
    fP = y(end,(1:3:end)); % final row; element 1, +3, elem. 4, etc. until end
    fF1 = y(end,(2:3:end));
    fF2 = y(end,(3:3:end));
#+end_src

*** Dispersal phase

#+begin_src matlab :tangle simMutualism.m
%   DISPERSAL
    n1P = fft_conv(kP,fP);   % dispersing individuals
    n1F1 = fft_conv(kF1,fF1);
    n1F2 = fft_conv(kF2,fF2);

    nP(generation + 1,:) = dx*n1P(nodes:length(x2)); %the convolution apparently doubles the length of the array?
    nF1(generation + 1,:) = dx*n1F1(nodes:length(x2));
    nF2(generation + 1,:) = dx*n1F2(nodes:length(x2));

    nP(generation + 1,1) = nP(generation + 1,1)/2; nP(generation + 1,nodes) = nP(generation + 1,nodes)/2; %The population density at the edges is halved

    nF1(generation + 1,1) = nF1(generation + 1,1)/2; nF1(generation + 1,nodes) = nF1(generation + 1,nodes)/2;

    nF2(generation + 1,1) = nF2(generation + 1,1)/2; nF2(generation + 1,nodes) = nF2(generation + 1,nodes)/2;

    temp_P = find(nP(generation + 1,:) < lowval); %gives location of random places where numbers are above zero due to some numerical errors
    temp_F1 = find(nF1(generation + 1,:) < lowval);
    temp_F2 = find(nF2(generation + 1,:) < lowval);

    nP(generation + 1,temp_P) = zeros(size(nP(generation + 1,temp_P))); %set the places with those numerical errors to zero
    nF1(generation + 1,temp_F1) = zeros(size(nF1(generation + 1,temp_F1)));%delete this for STE
    nF2(generation + 1,temp_F2) = zeros(size(nF2(generation + 1,temp_F2)));%delete this for STE

    jj_P = find(nP(generation + 1,:) >= nThreshold,1,'last');
    jj_F1 = find(nF1(generation + 1,:) >= nThreshold,1,'last');
    jj_F2 = find(nF2(generation + 1,:) >= nThreshold,1,'last');

    % if any of the species' range edge is equal to the edge of the entire
    % spatial range, stop the growth-dispersal loop. We set total iterations to
    % the last iteration + 1 so the data is still usable.
    if (jj_P == nodes) | (jj_F1 == nodes) | (jj_F2 == nodes)
        iterations = generation;
        disp("Warning: the simulation was stopped because one or more species have reached the edge of the landscape.");
        break;
    end

    if jj_P
         rangeEdgeP(generation + 1) = interp1(nP(generation + 1,jj_P:jj_P + 1),x(jj_P:jj_P + 1),nThreshold);
    end

    if jj_F1
         rangeEdgeF1(generation + 1) = interp1(nF1(generation + 1,jj_F1:jj_F1 + 1),x(jj_F1:jj_F1 + 1),nThreshold);
    end

    if jj_F2
         rangeEdgeF2(generation + 1) = interp1(nF2(generation + 1,jj_F2:jj_F2 + 1),x(jj_F2:jj_F2 + 1),nThreshold);
    end

    avgSpeedP(generation) = (rangeEdgeP(generation + 1) - rangeEdgeP(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time
    instantSpeedP(generation) = rangeEdgeP(generation + 1) - rangeEdgeP(generation);

    instantSpeedF1(generation) = rangeEdgeF1(generation + 1) - rangeEdgeF1(generation);
    avgSpeedF1(generation) = (rangeEdgeF1(generation + 1) - rangeEdgeF1(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time

    instantSpeedF2(generation) = rangeEdgeF2(generation + 1) - rangeEdgeF2(generation);
    avgSpeedF2(generation) = (rangeEdgeF2(generation + 1) - rangeEdgeF2(1)) / generation; %latest position of wave edge - initial position of wave edge divided by time
#+end_src

*** Determine whether to continue running the simulation for more iterations

#+begin_src matlab :tangle simMutualism.m
    % check for steady state, and determine whether to run for more generations
    if (generation == iterations)

        % if not all species at steady state
        if ~(isSpeciesSteadyState(instantSpeedP, steadyStateThreshold, generation) && isSpeciesSteadyState(instantSpeedF1, steadyStateThreshold, generation) && isSpeciesSteadyState(instantSpeedF2, steadyStateThreshold, generation))

            % iterations close to the max
            if iterations >= (maxIterations - iterationStep)
                iterations = maxIterations;
            else
                iterations = iterations + iterationStep;
            end
        end
    end

    generation = generation + 1;

% while loop end
end
#+end_src

*** Checking if a species is at a steady state

This function takes the spread speed values for a given species and checks to see if the variance in the last 10 values is at or below a threshold to determine whether a steady state has been reached.

#+begin_src matlab :tangle isSpeciesSteadyState.m
function isSteadyState = isSpeciesSteadyState(speed, tolerance, generation)
% takes a matrix of speed values and checks whether the variance in the last 10 values is at or below a threshold

    variance = sqrt(var(speed((generation - 9):generation)));

    if variance <= tolerance
        isSteadyState = true;
    else
        isSteadyState = false;
    end
end
#+end_src

*** Generate and save a mat file for the simulation

Using =maxIterations= to create the initial arrays means that these arrays may be storing many more rows than is actually necessary. Since we're saving these to mat files, we can reduce the size before saving by resizing the arrays. By getting rid of extra rows, we can also use the =end= index to get the population densities of the final iteration.

Then we can save our results to a mat file, which can then be used to generate figures, identify outcomes, etc. The =filename= string can be reused for saving figures as well. It takes any explicitly defined parameters from the call to =simMutualism()= and appends the names and values to =filename=.

#+begin_src matlab :tangle simMutualism.m
%% Save a mat file with the current parameter values

nP = nP(1:(iterations + 1), :);
nF1 = nF1(1:(iterations + 1), :);
nF2 = nF2(1:(iterations + 1), :);

instantSpeedP = instantSpeedP(1, 1:(iterations + 1));
instantSpeedF1 = instantSpeedF1(1, 1:(iterations + 1));
instantSpeedF2 = instantSpeedF2(1, 1:(iterations + 1));

%% Save a mat file with the current parameter values

filename = 'results';
formatSpec = '%.2f';

if ~(isempty(parameters))
    for i = 1:length(parameters)
        param = parameters{i};

        if isnumeric(param)
            param = num2str(param, formatSpec);
        elseif strcmp(param, 'outputDir') || isfolder(param)
            continue
        else
            param = string(param);
        end

        filename = strcat(filename, '_', param);
    end
end

filename = strcat(filename, '.mat');

save(strcat(outputDir, filename), 'nP', 'nF1', 'nF2', 'iterations', 'nThreshold', 'instantSpeedP', 'instantSpeedF1', 'instantSpeedF2', 'filename', 'parameters', 'x', 'maxIterations', 'diameter');

% end of simMutualism function
end
#+end_src

* Growth Model

Here we define the growth of each species using a system of ODEs.

** System of Equations (=growthODEs.m=)

*** Function definition

With =varargin=, we can optionally use parameter values other than the defaults, e.g. =growthODEs(t, y, 'rP', 0.4)=. We need to use an [[https://www.mathworks.com/help/matlab/ref/inputparser.html][inputParser]] to manage the function's parameters.

#+begin_src matlab :tangle growthODEs.m

% function dydt = growthODEs(t, y, r1, r2, alpha12, alpha21, q1, q2, beta1, beta2, c1, c2, d1, d2, h1, h2,e1, e2, nodes, dep_p, dep_f, comp_12, comp_21)
function dydt = growthODEs(t, y, varargin)

#+end_src

*** Default parameter values

We set our default parameter values here. If the parameter is not explicitly defined in the function call, then these default values are used.

#+begin_src matlab :tangle growthODEs.m

    %% Default ODE parameter values

    default_nodes = (2^16) + 1;

    % intrinsic growth
    default_rP = 0.3;
    default_rF1 = 0.3;
    default_rF2 = 0.3;

    % mutualism benefits
    default_alphaPF1 = 0.5;
    default_alphaPF2 = 0.5;
    default_alphaF1P = 0.5;
    default_alphaF2P = 0.5;

    default_qP = 1.0;
    default_qF1 = 1.0;
    default_qF2 = 1.0;

    % mutualism costs
    default_betaP = 0.0;
    default_betaF1 = 0.0;
    default_betaF2 = 0.0;

    default_cP = 1.0;
    default_cF1 = 1.0;
    default_cF2 = 1.0;

    % death rate
    default_dP = 0.1;
    default_dF1 = 0.1;
    default_dF2 = 0.1;

    % saturation
    default_hPF1 = 0.3;
    default_hPF2 = 0.3;
    default_hF1P = 0.3;
    default_hF2P = 0.3;

    default_eP = 0.3;
    default_eF1 = 0.3;
    default_eF2 = 0.3;

    % = 0.0;
    default_deltaP = 0.0;
    default_deltaF1 = 0.9;
    default_deltaF2 = 0.1;

    % competition: tau12 is the effect F2 has on F1; tau21 is effect of F1 on F2
    default_tau12 = 0.0;
    default_tau21 = 0.0;

#+end_src

*** Adding parameters with =inputParser=

See [[https://www.mathworks.com/help/matlab/ref/inputparser.html][inputParser]] and [[https://www.mathworks.com/help/matlab/ref/inputparser.addparameter.html][addParameter]] documentation. By setting =p.KeepUnmatched = true=, we can pass along all the parameters given in the simMutualism function call and just ignore the ones that are not relevant to the ODE parameters.

#+begin_src matlab :tangle growthODEs.m

    p = inputParser;
    p.KeepUnmatched = true;

    addRequired(p, 't');
    addRequired(p, 'y');

    %% Optional ODE parameters

    addParameter(p, 'nodes', default_nodes);

    % intrinsic growth rates
    addParameter(p, 'rP', default_rP);
    addParameter(p, 'rF1', default_rF1);
    addParameter(p, 'rF2', default_rF2);

    % mutualism benefits
    addParameter(p, 'alphaPF1', default_alphaPF1);
    addParameter(p, 'alphaPF2', default_alphaPF2);
    addParameter(p, 'alphaF1P', default_alphaF1P);
    addParameter(p, 'alphaF2P', default_alphaF2P);

    addParameter(p, 'qP', default_qP );
    addParameter(p, 'qF1', default_qF1);
    addParameter(p, 'qF2', default_qF2);

    % mutualism costs
    addParameter(p, 'betaP', default_betaP);
    addParameter(p, 'betaF1', default_betaF1);
    addParameter(p, 'betaF2', default_betaF2);

    addParameter(p, 'cP', default_cP);
    addParameter(p, 'cF1', default_cF1);
    addParameter(p, 'cF2', default_cF2);

    % death rate
    addParameter(p, 'dP', default_dP);
    addParameter(p, 'dF1', default_dF1);
    addParameter(p, 'dF2', default_dF2);

    % saturation
    addParameter(p, 'hPF1', default_hPF1);
    addParameter(p, 'hPF2', default_hPF2);
    addParameter(p, 'hF1P', default_hF1P);
    addParameter(p, 'hF2P', default_hF2P);

    addParameter(p, 'eP', default_eP);
    addParameter(p, 'eF1', default_eF1);
    addParameter(p, 'eF2', default_eF2);

    % mutualism dependence
    addParameter(p, 'deltaP', default_deltaP);
    addParameter(p, 'deltaF1', default_deltaF1);
    addParameter(p, 'deltaF2', default_deltaF2);

    % competition
    addParameter(p, 'tau12', default_tau12);
    addParameter(p, 'tau21', default_tau21);

    parse(p, t, y, varargin{:});

    % relabel variables so they're easier to read in the equation

    t = p.Results.t;
    y = p.Results.y;
    nodes = p.Results.nodes;

    % intrinsic growth
    rP = p.Results.rP;
    rF1 = p.Results.rF1;
    rF2 = p.Results.rF2;

    % mutualism benefits
    alphaPF1 = p.Results.alphaPF1;
    alphaPF2 = p.Results.alphaPF2;
    alphaF1P = p.Results.alphaF1P;
    alphaF2P = p.Results.alphaF2P;

    qP = p.Results.qP;
    qF1 = p.Results.qF1;
    qF2 = p.Results.qF2;

    % mutualism costs
    betaP = p.Results.betaP;
    betaF1 = p.Results.betaF1;
    betaF2 = p.Results.betaF2;

    cP = p.Results.cP;
    cF1 = p.Results.cF1;
    cF2 = p.Results.cF2;

    % death rate
    dP = p.Results.dP;
    dF1 = p.Results.dF1;
    dF2 = p.Results.dF2;

    % saturation
    hPF1 = p.Results.hPF1;
    hPF2 = p.Results.hPF2;
    hF1P = p.Results.hF1P;
    hF2P = p.Results.hF2P;

    eP = p.Results.eP;
    eF1 = p.Results.eF1;
    eF2 = p.Results.eF2;

    % mutualism dependence
    deltaP = p.Results.deltaP;
    deltaF1 = p.Results.deltaF1;
    deltaF2 = p.Results.deltaF2;

    % competition: tau12 is the effect F2 has on F1; tau21 is effect of F1 on F2
    tau12 = p.Results.tau12;
    tau21 = p.Results.tau21;

    y = reshape(y,3,nodes);
    dydt  = zeros(size(y));


#+end_src

*** Species /P/


\begin{align*}
\frac{dP}{dt} = P\left[ (1 - \deltaP) r_P &+ \deltaP \left( c_1 \left[\frac{\alpha_{PF_1} F_1}{h_P_1 + F_1}  + \frac{\alpha_{PF_2} F_2}{h_P_2 + F_2} \right] \right) \\
&- \delta_{F1} \left( q_1 \left[ \frac{\beta_{P} F_1}{e_P + P} \right] \right) - \delta_{F2} \left( q_1 \left[ \frac{\beta_{P} F_2}{e_P + P} \right] \right) - d_{P} P \right]
\end{align*}

#+begin_src matlab :tangle growthODEs.m

    % rename variables so equations are easier to read
    P = y(1,:);
    F1 = y(2,:);
    F2 = y(3,:);

    dydt(1,:) = P .* ((1 - deltaP) * rP + deltaP * (cP * ((alphaPF1 .* F1) ./ (hPF1 + F1) + (alphaPF2 .* F2) ./ (hPF2 + F2))) - deltaF1 * (qP * (betaP .* F1 ./ (eP + P))) - deltaF2 * (qP * (betaP .* F2 ./ (eP + P))) - (dP .* P));

#+end_src

*** Species /F/, Phenotype 1

$$
\frac{dF_1}{dt} = F_1[(1 - \delta_{F_1})r_{F_1} + \delta_{F_1} \left( c_2 \left[\frac{\alpha_{F_1P}P}{h_{F_1} + P} \right] \right) - \deltaP \left(q_2  \left[ \frac{\beta_{F_1}P}{e_{F_1} + F_1} \right] \right) - \tau_{12}F_2 - d_{F_1}F_1]
$$

#+begin_src matlab :tangle growthODEs.m

    dydt(2,:) = F1 .* ((1 - deltaF1) * rF1 + cF1 * (deltaF1 * (alphaF1P .* P) ./ (hF1P + P)) - qF1 * (deltaP * ((betaF1 .* P) ./ (eF1 + F1))) - (tau12 .* F2) - (dF1 .* F1));
#+end_src

*** Species /F/, Phenotype 2

$$
\frac{dF_2}{dt} = F_2[(1 - \delta_{F_2})r_{F_2} + \delta_{F_2} \left(c_2 \left[\frac{\alpha_{F_2P}P}{h_{F_2} + P} \right] \right) - \deltaP \left(q_2  \left[ \frac{\beta_{F_2}P}{e_{F_2} + F_2} \right] \right) - \tau_{21}F_1 - d_{F_2}F_2]
$$

#+begin_src matlab :tangle growthODEs.m

    dydt(3,:) = F2 .* ((1 - deltaF2) * rF2 + cF2 * (deltaF2 * (alphaF2P .* P) ./ (hF2P + P)) - qF2 * (deltaP * ((betaF2 .* P) ./ (eF2 + F2))) - (tau21 .* F1) - (dF2 .* F2));

#+end_src

*** Reshape

#+begin_src matlab :tangle growthODEs.m

    dydt = reshape(dydt,3*nodes,1);
end

#+end_src

* Parameter sweep

** Sweep script

This is the main file to be edited when running parameter sweeps. The =simMutualism()= function requires an output directory as an argument. It can take any ODE parameter as an optional argument. to override a default value, use the parameter variable name then a value, i.e. =simMutualism(outputDir, 'tau12', 0.3, 'tau21', 0.14)=. These variables will get added to the filename of the exported mat file at the end of the simulation.

We can adjust values of =maxIterations= in the for loop to allow for longer simulations of $\tau$ values that we know will take longer to reach a steady state. By allow for more iterations for only these values, we limit the number of very large mat files.

#+begin_src matlab :tangle tauSweep.m
% use integers for the number of iterations to run (rather than the actual
% values of tau12 and tau21) because it seems parfor requires it

maxIterations = 1000;
rangeStep = 0.01;

outputDir = '/home/shawa/lutzx119/tauSweep/';

% instead of using a for loop for the tau12 values, we can use Slurm to set up
% jobs for each tau12 value. To change the range of tau12 values, modify the
% "SBATCH --array=" line in the Slurm job script.
tau12 = rangeStep * str2num(getenv("SLURM_ARRAY_TASK_ID"));

parfor j = 0:40

    tau21 = j * rangeStep;

    % more iterations for tau values that result in regional coexistence
    if (tau12 > 0.13 && tau12 < 0.25 && tau21 < 0.15) || (tau21 > 0.28 && tau12 > 0.23 && tau12 < 0.3)
        simMutualism('outputDir', outputDir, 'tau12', tau12, 'tau21', tau21, 'maxIterations', maxIterations, 'diameter', 3600);
    else
        simMutualism('outputDir', outputDir, 'tau12', tau12, 'tau21', tau21);
    end

end
#+end_src


** Slurm job script

Note that the $SBATCH lines *must* be at the top of the script. Anything before that will break Slurm.

#+begin_comment
For this reason, I'm not setting up detangling for the jobscript.
#+end_comment


#+begin_src shell :tangle jobscript.sh :comments none
#!/bin/bash -l
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=4
#SBATCH --mem-per-cpu=4G
#SBATCH --time=2:00:00
#SBATCH --array=0-40
#SBATCH --mail-type=ALL
#SBATCH --mail-user=lutzx119@umn.edu
#SBATCH --output=/home/shawa/lutzx119/reports/tausweep-%j.out

cd /home/shawa/lutzx119/mutualism
module purge

module load matlab
matlab -nodisplay <tauSweep.m

#+end_src

** Function to classify outcome (=classifyOutcome.m=)

This function takes the final population densities of species $F_1$ and $F_2$ and classifies the outcome of the simulation. The possible outcomes are:

- F1 dominance (=outcome = 1=)
- F2 dominance (=outcome = 2=)
- local coexistence (=outcome = 3=)
- local coexistence with F1 dominance (=outcome = 4=)
- local coexistence with F2 dominance (=outcome = 5=)
- regional coexistence (=outcome = 6=)
- unknown (=outcome = 7=).

First we find the values above =nThreshold= across the landscape — this gives us each species final range. We use the =max= function to determine whether $F_1$ or $F_2$ had the bigger range.

In order to make classification easier we create a variable that tells us whether or not $F_1$ had the larger range than $F_2$, based on the result of the =max= function.

#+begin_src matlab :tangle classifyOutcome.m

%% Function to classify outcome of a given simulation
function outcome = classifyOutcome(finalNF1, finalNF2, nThreshold);

    % get the ranges where F1 and F2 populations are above the threshold
    rangeF1 = find(finalNF1 >= nThreshold);
    rangeF2 = find(finalNF2 >= nThreshold);

    maxRange = max(length(rangeF1), length(rangeF2));

    if length(rangeF1) == maxRange
        isF1Dominant = true;
    else
        isF1Dominant = false;
    end

    % maxRange = size(rangeP);
#+end_src

In the simplest cases, there were no population values above =nThreshold= for either $F_1$ or $F_2$; this means the other species competitively excluded it and we can classify the outcome as /$F_1$ or $F_2$ dominance/.

#+begin_src matlab :tangle classifyOutcome.m
    % if F2 is below the threshold across the total range, then classify as
    % F1 dominance
    if isempty(rangeF2)
        outcome = 1; % F1 dominance

    % if F1 is below the threshold across the total range, then classify as
    % F2 dominance
    elseif isempty(rangeF1)
        outcome = 2; % F2 dominance

#+end_src

Next, we look to see if the $F$ species with the larger range was dominant for less than 0.05 of its total range. The =setxor= function gives us the areas of space where the species with the greater range competitively excluded the other. We determine the total length of these areas and then divide by =maxRange= to get the proportion of the total range where this species was dominant. If this proportion is less than the (arbitrary) threshold of 0.05, we classify this as /local coexistence/.

#+begin_src matlab :tangle classifyOutcome.m

    % find the range of values in rangeF1 or rangeF2 but not both
    % if the proportion of this range over the total range is less than
    % the arbitrary value 0.05, we call it local coexistence
    elseif length(setxor(rangeF1, rangeF2))/maxRange < 0.05
        outcome = 3; % Local coexistence
#+end_src

It's possible that the proportion of space where the dominant species competitively excluded the other is greater than 0.05. In this case, we first determine if $F_1$ was the dominant species (i.e. it had the larger range). Since we've already found outcomes where the lengths of the ranges of $F_1$ and $F_2$ differ by less than 5%, we know that any outcomes found here will have at least some local dominance.

Since =setxor(rangeF1, rangeF2)= gives us any area of the landscape where one species competitively excluded the other, we use =intersect= to see if any of those areas fall within =rangeF2=. In other words, if $F_2$ competitively excluded $F_1$ for any proportion of the landscape. If so, we classify this as /regional coexistence/.

If not, this means that $F_1$ has regions of its total range where it has competitively excluded $F_2$ (the proportion of which must be greater than or equal to 0.05). We know from the comparisons above, however, that $F_1$ still occupies some proportion of the landscape, so we classify this as /local coexistence with $F_1$ dominance/.

We then make the same comparisons when $F_2$ has the larger range. Finally, we classify any outcome that does not fall into these categories as "unknown", which most likely indicates some sort of error.

#+begin_src matlab :tangle classifyOutcome.m

    elseif length(rangeF1) > length(rangeF2)

        % we find at least some F2 dominance
        if intersect(rangeF2, setxor(rangeF1, rangeF2))
            outcome = 6; % regional coexistence

        % no F2 dominance
        else
            outcome = 4; % Local coexistence + F1 dominance
        end

    elseif length(rangeF2) > length(rangeF1)

        % we find at least some F1 dominance
        if intersect(rangeF1, setxor(rangeF1, rangeF2))
            outcome = 6; % regional coexistence
        else
            outcome = 5; % Local coexistence + F2 dominance
        end
    else
        outcome = 7; % unknown
    end
end
#+end_src

* Figures

** Generate plots for paper

#+begin_src matlab :tangle generatePlots.m :comments link
sweepDir = '~/tauSweep/';
figDir = '~/figures/';
formatSpec = '%.2f';

% get the heatmap of all the outcomes
plotOutcomes(sweepDir, 'figDir', figDir);

% tau12 and tau21 pairs
taus = [0 0; 0.05 0; 0.05 0.05; 0.05 0.10; 0.15 0.05; 0.20 0.05; 0.20 0.15; 0.25 0.05; 0.23 0.37; 0.26 0.37; 0.35 0.37];

for i = length(taus)
    filename = strcat(sweepDir, "results_tau12_", num2str(taus(i, 1), formatSpec), "_tau21_", num2str(taus(i, 2), formatSpec), ".mat");

    plotPopSpaceTime(filename, 'figDir', figDir);

    plotFinalPopSpace(filename, 'figDir', figDir);

    plotSpeedTime(filename, 'figDir', figDir);
end
#+end_src

** 3D population density vs. space vs. time plots

These plots are helpful to see how the population densities change over time, but the 2D final spatial outcome plots are a little easier to read if all we care about is what happens at the steady state.

We generate a plot for each species, and they're superimposed in a single figure.

#+begin_src matlab :tangle plotPopSpaceTime.m

function plotPopSpaceTime(simMatFile, varargin)

    p = inputParser;
    addRequired(p, 'simMatFile', @isfile);
    addOptional(p,'createFig', true, @islogical);
    addOptional(p, 'figDir', './', @isfolder);

    parse(p, simMatFile, varargin{:});

    load(p.Results.simMatFile, 'filename', 'iterations', 'nP', 'nF1', 'nF2', 'nThreshold', 'x');

    timeStep = round(iterations / 10);

    %% Figure for species P
    figure(1);
    clf
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = nP;
    nlow(nP >= nThreshold) = NaN;
    nP(nP < nThreshold) = NaN;

    rangeP = x(find(nP(end,:) >= nThreshold));

    rangeMin = min(rangeP);
    rangeMax = max(rangeP);

    hold on
    for i = 1:timeStep:iterations
        lineP = plot3(xx(i,:),tt(i,:),nP(i,:),'b', 'LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end
    % plot3(rangeEdgeP(1:11),0:10,nThreshold*ones(1,11),'k');
    axis([(rangeMin - 5) (rangeMax + 5) 0 iterations 0 6.25]);
    xlabel('Spatial range');
    ylabel('Generations');
    zlabel('Population density');
    % title('Species P');
    view(30,30);

    %% Figure for species F1
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = nF1;
    nlow(nF1 >= nThreshold) = NaN;
    nF1(nF1 < nThreshold) = NaN;
    hold on
    for i = 3:timeStep:iterations
        lineF1 = plot3(xx(i,:),tt(i,:),nF1(i,:),'r','LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end

    %% Figure for species F2
    [xx,tt] = meshgrid(x,0:iterations);
    nlow = nF2;
    nlow(nF2 >= nThreshold) = NaN;
    nF2(nF2 < nThreshold) = NaN;
    hold on
    for i = 5:timeStep:iterations
        lineF2 = plot3(xx(i,:),tt(i,:),nF2(i,:),'g', 'LineWidth', 3.0);
        plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
        grid on
    end
    hold off

    legend([lineP lineF1 lineF2], {'P', 'F_1', 'F_2'});

    if p.Results.createFig
        [~, filename, ~] = fileparts(filename);
        filename = strcat('pop_space_time_', filename, '.fig');
        savefig(strcat(p.Results.figDir, filename));
    end

end
#+end_src

** Speed vs. time

#+begin_src matlab :tangle plotSpeedTime.m
function plotSpeedTime(simMatFile, varargin)

    p = inputParser;
    addRequired(p, 'simMatFile', @isfile);
    addOptional(p,'createFig', true, @islogical);
    addOptional(p, 'figDir', './', @isfolder);

    parse(p, simMatFile, varargin{:});

    load(simMatFile, 'filename', 'iterations', 'instantSpeedP', 'instantSpeedF1', 'instantSpeedF2');

    plot(1:(iterations + 1), instantSpeedP, 1:(iterations + 1), instantSpeedF1, 1:(iterations + 1), instantSpeedF2);
    legend('P', 'F1', 'F2');
    title(strcat(['Spread speed vs. time']));
    xlabel('iterations');
    ylabel('speed');

    if p.Results.createFig
        [~, filename, ~] = fileparts(filename);
        filename = strcat('speed_time_', filename, '.fig');
        savefig(strcat(p.Results.figDir, filename));
    end
end
#+end_src

** Final population densities across space

 #+begin_src matlab :tangle plotFinalPopSpace.m

function plotFinalPopSpace(simMatFile, varargin)

    p = inputParser;
    addRequired(p, 'simMatFile', @isfile);
    addOptional(p,'createFig', true, @islogical);
    addOptional(p, 'figDir', './', @isfolder);

    parse(p, simMatFile, varargin{:});

    load(simMatFile, 'nP', 'nF1', 'nF2', 'iterations', 'filename');

    hold on
    plot(nP(iterations + 1,:));
    plot(nF1(iterations + 1,:));
    plot(nF2(iterations + 1,:));
    legend('P', 'F1', 'F2');
    title(strcat(['N vs. x']));
    hold off

    if p.Results.createFig
        [~, filename, ~] = fileparts(filename);
        filename = strcat('final_pop_space_', filename, '.fig');
        savefig(strcat(p.Results.figDir, filename));
    end
end
#+end_src

** Range vs. time

This plot shows how the overall range of each species changes over time.

In order to obtain the range of a species at a given time, you could find all the spatial points in the /n/ matrices (columns) where the value is greater than some minimum population. =nP= is a matrix with rows for each iteration and columns for each spatial point.

Does range size need to be contiguous? In other words, if F1 is only present at the edges, could you total its ranges at each edge and call that its "range size"?

#+begin_src matlab :tangle plotRangeTime.m

function plotRangeTime(simMatFile, varargin)

    p = inputParser;
    addRequired(p, 'simMatFile', @isfile);
    addOptional(p,'createFig', true, @islogical);
    addOptional(p, 'figDir', './', @isfolder);


    parse(p, simMatFile, varargin{:});

    load(simMatFile, 'filename', 'nThreshold', 'nP', 'nF1', 'nF2', 'iterations');

    for i = 1:(iterations + 1)

        rangeP(i) = length(find(nP(i,:) >= nThreshold));
        rangeF1(i) = length(find(nF1(i,:) >= nThreshold));
        rangeF2(i) = length(find(nF2(i,:) >= nThreshold));
    end

    plot(1:(iterations + 1), [rangeP; rangeF1; rangeF2]);
    xlabel('iterations');
    ylabel('range size');
    title(strcat(['Range size vs. time']));
    legend('P', 'F1', 'F2');

    if p.Results.createFig
        [~, filename, ~] = fileparts(filename);
        filename = strcat('range_time_', filename, '.fig');
        savefig(strcat(p.Results.figDir, filename));
    end
end

#+end_src

** Sweep outcomes plot

This function generates a heatmap of the outcomes of a $\tau$ parameter sweep (it might be possible to make this more generic for other types of parameter sweeps in the future). It requires a directory where it can find mat files (the results of each simulation).

It can optionally take arguments to specify the range of values used in the parameter sweep (by default it assumes that we used the range =0:0.01:0.40= for both $\tau_{12}$ and $\tau_{21}$).

#+begin_src matlab :tangle plotOutcomes.m
function plotOutcomes(sweepDir, varargin)

    p = inputParser;

    addRequired(p, 'sweepDir', @isfolder);
    addParameter(p, 'tau12Range', 0:0.01:0.40);
    addParameter(p, 'tau21Range', 0:0.01:0.40);
    addParameter(p, 'figDir', './', @isfolder);
    parse(p, sweepDir, varargin{:});

    tau12Range = p.Results.tau12Range;
    tau21Range = p.Results.tau21Range;
    figDir = p.Results.figDir;

    outcomes = zeros(length(tau12Range), length(tau21Range));

    files = dir(fullfile(sweepDir, '*.mat'));

    for file = 1:length(files)

        load(strcat(sweepDir, files(file).name), 'nF1', 'nF2', 'nThreshold', 'parameters');

        tau12 = parameters{find(strcmp('tau12', parameters)) + 1};
        tau21 = parameters{find(strcmp('tau21', parameters)) + 1};

        finalNF1 = nF1(end,:);
        finalNF2 = nF2(end,:);

        outcomes(tau12,tau21) = classifyOutcome(finalNF1, finalNF2, nThreshold);

    end

    figure(1)
    heatmap(tau12Range, fliplr(tau21Range), rot90(outcomes));
    xlabel('tau_{12}');
    ylabel('tau_{21}');

    filename = strcat(figDir, 'tauSweepOutcomesPlot.fig');
    savefig(filename);

end
#+end_src

** Populations vs. time plot


#+begin_src matlab :tangle pheno_pop_vs_time.m

% time span
tspan = 0.0:0.1:100.0;

% initial populations
initpop = [2.0; 2.0; 2.0];

r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];

nodes = 1;

[t,y] = ode45(@(t,y) growthODEs(t,y,r_p,r_f,alpha_pf,alpha_fp,q1,q2,beta1,beta2,c1,c2,d_p,d_f,h1,h2,e1,e2,nodes,dep_p,dep_f, comp_12, comp_21), tspan, initpop);

P = y(:,1);
F1 = y(:,2);
F2 = y(:,3);

% generate plot
figure;
plot(t, [P, F1, F2]);
legend('P', 'F1', 'F2');
xlabel('time');
ylabel('population');


#+end_src

** Phase space plot - P vs. F1 vs. F2 (=phenophase.m=)

In the two-species mutualism model, we took a range of possible starting population values (this is what we passed to the =meshgrid()= function to generate a matrix for each species). We then sent these matrices to our ODE function, which returned the growth rates for each combination of starting population values—this is how we got our vector field arrows.

*** Initial setup for 3D phase space plot

Here you generate the vector field with the =meshgrid()= and =quiver()= functions

#+begin_src matlab :tangle phenophase.m

maxpop = 10.0;
popRange = 0.0:0.5:maxpop;

[P, F1, F2] = meshgrid(popRange);

r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];
comp_12 = 1.0;
comp_21 = 4.0;

ystart = [P(:).'; F1(:).'; F2(:).'];
ystart = reshape(ystart, 3*length(ystart), 1);

dy = growthODEs(0, ystart, r_p, r_f, alpha_pf, alpha_fp, q1, q2, beta1, beta2, c1, c2, d_p, d_f, h1, h2, e1, e2, length(P(:).'), dep_p, dep_f, comp_12, comp_21);

dP = reshape(dy((1:3:end),:), length(P), length(P), length(P));
dF1 = reshape(dy((2:3:end),:), length(P), length(P), length(P));
dF2 = reshape(dy((3:3:end),:), length(P), length(P), length(P));

u = dP ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
v = dF1 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
w = dF2 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);

figure;
quiver3(P, F1, F2, u, v, w, 0.35);
xlabel('P');
ylabel('F1');
zlabel('F2');
hold on;

#+end_src

*** Plot isoclines

#+begin_src matlab :tangle phenophase.m

syms x y z
eq1 = ((1-dep_p).*r_p + dep_p .* (c1.*((alpha_pf(1).*y)./(h2(1)+y) + (alpha_pf(2).*z)./(h2(2)+z)))- ((dep_f(1)+dep_f(2))/2) .*(q1.*(beta1.*(y + z)./(e1+x)))-(d_p.*x));
eq2 = ((1-dep_f(1)).*r_f(1) + c2 .*(dep_f(1).*(alpha_fp(1).*x)./(h1(1)+x))-q2.*(dep_p.*((beta2(1).*x)./(e2(1)+y))) -(d_f(1).*y));
eq3 = ((1-dep_f(2)).*r_f(2) + c2 .*(dep_f(2).*(alpha_fp(2).*x)./(h1(2)+x))-q2.*(dep_p.*((beta2(2).*x)./(e2(2)+z))) -(d_f(2).*z));

fimplicit3(eq1, [0 maxpop]);
fimplicit3(eq2, [0 maxpop]);
fimplicit3(eq3, [0 maxpop]);

hold off;

#+end_src



* Results

** Table of results

=comp_12= is how F2 negatively impacts F1, and =comp_21= is how F1 negatively impacts F2 through competition.

| dep_f(1) | dep_f(2) | alpha21(1) | alpha21(2) | comp_12 | comp_21 | result  | dom. pheno |
|----------+----------+------------+------------+---------+---------+---------+------------|
|      0.1 |      0.9 |        0.5 |        0.5 |     0.5 |     0.4 | dom     | F1         |
|      0.1 |      0.9 |        0.5 |        0.5 |     0.2 |     0.1 | dom     | F1         |
|      0.1 |      0.9 |        0.5 |        0.5 |     0.1 |     0.2 | dom     | F2         |
|      0.1 |      0.9 |        0.5 |        0.5 |    0.01 |    0.02 | loc     | F2         |
|      0.5 |      0.9 |        0.5 |        0.5 |       1 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.8 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.5 |     0.4 | dom     | F1         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.4 |     2.3 | dom     | F2         |
|      0.5 |      0.9 |        0.5 |        0.5 |     0.4 |       1 | dom     | F2         |
|      0.6 |      0.9 |        0.5 |        0.5 |    0.08 |    0.04 | loc     | F1         |
|      0.6 |      0.9 |        0.5 |        0.5 |    0.08 |    0.03 | loc     | F2         |
|      0.7 |      0.9 |        0.5 |        0.5 |     0.1 |     0.2 | dom     | F2         |
|      0.7 |      0.9 |        0.5 |        0.5 |    0.01 |    0.02 | loc     | F2         |
|      0.9 |      0.6 |        0.5 |        0.5 |    0.08 |    0.04 | dom/loc | F1         |
|      0.9 |      0.6 |        0.5 |        0.7 |    0.08 |    0.04 | loc     | F1/F2      |
|      0.9 |      0.6 |        0.3 |        0.7 |    0.08 |    0.04 | dom/loc | F2         |
|      0.9 |      0.6 |        0.3 |        0.9 |    0.08 |    0.04 | dom/loc | F2         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.09 |    0.01 | dom     | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.07 |    0.01 | dom/loc | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.04 |    0.01 | dom/loc | F1         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.04 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |    0.04 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |    0.07 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |     0.1 | dom/loc | F1         |
|      0.9 |      0.1 |        0.8 |        0.5 |    0.01 |     0.4 | reg     | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |     0.4 | dom     | F2         |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.06 | dom/loc | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.09 | dom/loc | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |     0.2 | reg     | F1/F2      |
|      0.9 |      0.1 |        0.5 |        0.5 |    0.01 |    0.03 | dom/loc | F1/F2      |

** Interpretation

If we plot the two competition factors F1 and F2, we can determine where we find local coexistence, regional coexistence, and dominance. What we found is not entirely what we expected (specifically in the upper right region), where the competition factors are equal.



*** Defining local and regional coexistence

/Regional coexistence/ could be defined as both phenotypes being completely dominant in a portion of the total range at steady state.

/Local coexistence/ occurs when both phenotypes occupy the majority of the total range together at steady state.

*** Do we need 𝛅?



** 𝛕 sweep results

*** Interesting plots

**** Regional coexistence

=tau12 = 0.21=

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.21_comp_21=0.23.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.22_comp_21=0.25.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.23_comp_21=0.12.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.23_comp_21=0.27.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.24_comp_21=0.29.png]]

=tau12 = 0.24=

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.25_comp_21=0.31.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.27_comp_21=0.36.png]]

[[~/sweep2/figures/n_v_x/png/N_v_x_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]

[[~/sweep2/figures/range/png/range_size_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]

[[~/sweep2/figures/speed/png/speed_depF1=0.9_depF2=0.1_alphaF1=0.5_alphaF2=0.5_comp_12=0.28_comp_21=0.40.png]]


** Iterations issue

In order to see what happens in areas of regional coexistence over the long-term, we're attempting to run these simulations with 1000 iterations. Using the m file as-is, we get the error: ~Index in position 2 exceeds array bounds (must not exceed 65537)~

Clearly this is an issue with the number of nodes or the diameter. Space shouldn't change; it seems that in trying to increase the number of iterations you're increasing space somewhere.

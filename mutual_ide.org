#+title: Mutualism IDE Model

* Model

** ODE parameters

#+begin_src matlab :tangle mutual_ide.m

clc
%% original function parameters

iterations = 30;
tspan = [0, 10];
r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.8 0.9];

#+end_src

** Initialization

#+begin_src matlab :tangle mutual_ide.m

%% Initialize parameters
lowval = 1e-9;
diameter = 1200;  %total size of landscape along positive x-axis (so technically half the size of the total landscape)
nodes = (2^16)+1; %total points in space -- 65537
radius = diameter/2;
x = linspace(-radius,radius,nodes);
x2 = linspace(-diameter,diameter,2*nodes-1);
dx = diameter/(nodes-1);
[speed_inst_P,speed_av_P, speed_inst_F1,speed_av_F1, speed_inst_F2, speed_av_F2] = deal(zeros(1,iterations)); %assign initializing values to each of the arrays
[xright_P,xright_F1, xright_F2] = deal(zeros(1,iterations+1)); %array with 1 row and 201 columns. tells us the farthest a population has reached
[n_P,n_F1, n_F2] = deal(zeros(iterations+1,length(x))); %array with 201 rows and 65537 columns. tells us population density at each node along column and each time step/iteration is one row. define ,f_P_all,f_F_all if you wish to do post census calculations

irad = 2;       % Intial condition range%irad_F = 2;% irad_F = diameter if you want to study STE (semi trivial equlibria);
                %irad_F = 2;
idens = [0.1,0.1];
ncrit = 0.05;   % critical threshold for edge of wave
sigma_sq = 0.25;            % Dispersal variance
k_P = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq); % this line and the next describes a gaussian dispersal kernel
k_F = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq); %make k_F = 0 for STE to prevent dispersal of individuals which are already in the entire space (F is arbit. -- could be P as well)

% k_P = exp(-sqrt(2*(x2.^2)/(sigma_sq)))./sqrt(2*sigma_sq); %this line and the next describe a laplacian dispersal kernel
% k_F = exp(-sqrt(2*(x2.^2)/(sigma_sq)))./sqrt(2*sigma_sq);

% SET THE INITIAL CONDITIONS
temp_P = find(abs(x) <= irad); %locate all values in the array x that lie b/w +irad and -irad units of space
temp_F1 = find(abs(x) <= irad); %irad_F for STE
temp_F2 = find(abs(x) <= irad); %irad_F for STE

n_P(1,temp_P) = idens(1)*normpdf(x(temp_P),0,1); %Computes pdf values evaluated at the values in x i.e. all x(temp) values for the normal distribution with mean 0 and standard deviation 1.
n_F1(1,temp_F1) = idens(2)*normpdf(x(temp_F1),0,1); %Would be just idens(2) for STE
n_F2(1,temp_F2) = idens(2)*normpdf(x(temp_F2),0,1); %Would be just idens(2) for STE
%2 Lines below are for studying spatial spread with census after growth
% f_P_all(1,temp_P) = idens(1)*normpdf(x(temp_P),0,1); %Computes pdf values evaluated at the values in x i.e. all x(temp) values for the normal distribution with mean 0 and standard deviation 1.
% f_F_all(1,temp_F) = idens(2)*normpdf(x(temp_F),0,1);

% FIND THE INITIAL FRONT LOCATION
jj_P = find(n_P(1,:) >= ncrit,1,'last'); %find the farthest distance travelled by the population above a certain threshold density and assign it to jj
jj_F1 = find(n_F1(1,:) >= ncrit,1,'last'); %remove all jj_F mentions if you want to calculate speeds of semi trivial equilibria
jj_F2 = find(n_F2(1,:) >= ncrit,1,'last');

%2 Lines below are for studying spatial spread with census after growth
% f_jj_P = find(f_P_all(1,:) >= ncrit,1,'last'); %find the farthest distance travelled by the population above a certain threshold density and assign it to jj
% f_jj_F = find(f_F_all(1,:) >= ncrit,1,'last');

if jj_P %the initial front is obtained from initialization which will be in the first row of 'n'
  xright_P(1) = interp1(n_P(1,jj_P:jj_P+1),x(jj_P:jj_P+1),ncrit);
end
if jj_F1
  xright_F1(1) = interp1(n_F1(1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),ncrit);
end

if jj_F2
  xright_F2(1) = interp1(n_F2(1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),ncrit);
end
%6 Lines below are for studying spatial spread with census after growth
% if f_jj_P %the initial front is obtained from initialization which will be in the first row of 'n'
%   xright_P(1) = interp1(f_P_all(1,f_jj_P:f_jj_P+1),x(f_jj_P:f_jj_P+1),ncrit);
% end
% if f_jj_F
%   xright_F(1) = interp1(f_F_all(1,f_jj_F:f_jj_F+1),x(f_jj_F:f_jj_F+1),ncrit);
% end

#+end_src

** Growth and dispersal

#+begin_src matlab :tangle mutual_ide.m

%% Looping for growth and dispersal
for i = 1:iterations
    %Growth
    y0 = [n_P(i,:);n_F1(i,:);n_F2(i,:)];
    y0 = reshape(y0, 3*length(y0), 1); % reshape happens such that pairs of n_P and n_F values are located in adjacent rows to each other
    [t,y] = ode45(@(t,y) odephenotypes(t,y,r_p,r_f,alpha_pf,alpha_fp,q1,q2,beta1,beta2,c1,c2,d_p,d_f,h1,h2,e1,e2,nodes,dep_p,dep_f), tspan, y0); %remember to alter where the dep_p and dep_f are being called from
    f_P = y(end,(1:3:end));
    f_F1 = y(end,(2:3:end));
    f_F2 = y(end,(3:3:end));
%6 Lines below are for studying spatial spread with census after growth
%     f_P_all(i+1,:) = f_P;
%     f_F_all(i+1,:) = f_F;
%     temp_P = find(f_P_all(i+1,:) < lowval); %gives location of random places where numbers are above zero due to some numerical errors
%     temp_F = find(f_F_all(i+1,:) < lowval);
%     f_P_all(i+1,temp_P) = zeros(size(f_P_all(i+1,temp_P))); %set the places with those numerical errors to zero
%     f_F_all(i+1,temp_F) = zeros(size(f_F_all(i+1,temp_F)));
%

%   DISPERSAL
    n1_P = fft_conv(k_P,f_P);   % dispersing individuals
    n1_F1 = fft_conv(k_F,f_F1);
    n1_F2 = fft_conv(k_F,f_F2);

    n_P(i+1,:) = dx*n1_P(nodes:length(x2)); %the convolution apparently doubles the length of the array?
    n_F1(i+1,:) = dx*n1_F1(nodes:length(x2)); %MAKE n_F(i+1, :) = r_f/d_f if you want to look at cases of semi-trivial equilibrium;
    n_F2(i+1,:) = dx*n1_F2(nodes:length(x2)); %MAKE n_F(i+1, :) = r_f/d_f if you want to look at cases of semi-trivial equilibrium;

    n_P(i+1,1) = n_P(i+1,1)/2; n_P(i+1,nodes) = n_P(i+1,nodes)/2; %The population density at the edges is halved
    n_F1(i+1,1) = n_F1(i+1,1)/2; n_F1(i+1,nodes) = n_F1(i+1,nodes)/2;
    n_F2(i+1,1) = n_F2(i+1,1)/2; n_F2(i+1,nodes) = n_F2(i+1,nodes)/2;

    temp_P = find(n_P(i+1,:) < lowval); %gives location of random places where numbers are above zero due to some numerical errors
    temp_F1 = find(n_F1(i+1,:) < lowval);%delete this for STE
    temp_F2 = find(n_F2(i+1,:) < lowval);%delete this for STE

    n_P(i+1,temp_P) = zeros(size(n_P(i+1,temp_P))); %set the places with those numerical errors to zero
    n_F1(i+1,temp_F1) = zeros(size(n_F1(i+1,temp_F1)));%delete this for STE
    n_F2(i+1,temp_F2) = zeros(size(n_F2(i+1,temp_F2)));%delete this for STE

    jj_P = find(n_P(i+1,:) >= ncrit,1,'last');
    jj_F1 = find(n_F1(i+1,:) >= ncrit,1,'last');
    jj_F2 = find(n_F2(i+1,:) >= ncrit,1,'last');

%     %2 Lines below are for studying spatial spread with census after growth
%     f_jj_P = find(f_P_all(i+1,:) >= ncrit,1,'last');
%     f_jj_F = find(f_F_all(i+1,:) >= ncrit,1,'last');

    if jj_P
         xright_P(i+1) = interp1(n_P(i+1,jj_P:jj_P+1),x(jj_P:jj_P+1),ncrit);
    end

    if jj_F1
         xright_F1(i+1) = interp1(n_F1(i+1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),ncrit);
    end

    if jj_F2
         xright_F2(i+1) = interp1(n_F2(i+1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),ncrit);
    end

%6 Lines below are for studying spatial spread with census after growth
%     if f_jj_P
%          xright_P(i+1) = interp1(f_P_all(i+1,f_jj_P:f_jj_P+1),x(f_jj_P:f_jj_P+1),ncrit);
%     end
%
%     if f_jj_F
%          xright_F(i+1) = interp1(f_F_all(i+1,f_jj_F:f_jj_F+1),x(f_jj_F:f_jj_F+1),ncrit);
%     end
%

    speed_av_P(i) = (xright_P(i+1)-xright_P(1))/i; %latest position of wave edge - initial position of wave edge divided by time
    speed_inst_P(i) = xright_P(i+1)-xright_P(i);



    speed_inst_F1(i) = xright_F1(i+1)-xright_F1(i);
    speed_av_F1(i) = (xright_F1(i+1)-xright_F1(1))/i; %latest position of wave edge - initial position of wave edge divided by time

    speed_inst_F2(i) = xright_F2(i+1)-xright_F2(i);
    speed_av_F2(i) = (xright_F2(i+1)-xright_F2(1))/i; %latest position of wave edge - initial position of wave edge divided by time

    %save(strcat(['mandm_yescost_depP=' num2str(dep_p) '_depF=' num2str(dep_f) '.mat']))
    %save mandm_nocost_yesdep.mat

end


#+end_src

* Figures

** 3D density vs. space vs. time plots

#+begin_src matlab :tangle mutual_ide.m

%% Figure for species P
figure(1);
clf
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_P;
nlow(n_P>=ncrit) = NaN;
n_P(n_P<ncrit) = NaN;
hold on
for i = 1:11
     plot3(xx(i,:),tt(i,:),n_P(i,:),'r');
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end
plot3(xright_P(1:11),0:10,ncrit*ones(1,11),'k');
    axis([-15 15 0 10 0 5]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('species P density (n_P)');
    title('Species P');
    view(30,30);

%% Figure for species F1
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_F1;
nlow(n_F1>=ncrit) = NaN;
n_F1(n_F1<ncrit) = NaN;
hold on
for i = 1:11
     plot3(xx(i,:),tt(i,:),n_F1(i,:),'g');
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end
plot3(xright_F1(1:11),0:10,ncrit*ones(1,11),'k');
    axis([-15 15 0 10 0 5]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('species F1 density (n_F1)');
    view(30,30);
    title('Species F1');

%% Figure for species F2
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_F2;
nlow(n_F2>=ncrit) = NaN;
n_F2(n_F2<ncrit) = NaN;
hold on
for i = 1:11
     plot3(xx(i,:),tt(i,:),n_F2(i,:),'b');
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end
plot3(xright_F2(1:11),0:10,ncrit*ones(1,11),'k');
    axis([-15 15 0 10 0 5]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('species F2 density (n_F2)');
    view(30,30);
    title('Species F2');
hold off

#+end_src

** Density vs. time plots

#+begin_src matlab :tangle no

t= 0:iterations;
plot(t, n_P, t, n_F1, t, n_F2)

#+end_src

** Phase space plot

In the two-species mutualism model, we took a range of possible starting population values (this is what we passed to the =meshgrid()= function to generate a matrix for each species). We then sent these matrices to our ODE function, which returned the growth rates for each combination of starting population valuesâ€”this is how we got our vector field arrows.

*** Initial setup for 3D phase space plot

Here you generate the vector field with the =meshgrid()= and =quiver()= functions

#+begin_src matlab :tangle phenophase.m

maxpop = 10.0;
popRange = 0.0:0.5:maxpop;

[P, F1, F2] = meshgrid(popRange);

r_p = 0.3;
r_f = [0.50 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];


ystart = [P(:).'; F1(:).'; F2(:).'];
ystart = reshape(ystart, 3*length(ystart), 1);

dy = odephenotypes(0, ystart, r_p, r_f, alpha_pf, alpha_fp, q1, q2, beta1, beta2, c1, c2, d_p, d_f, h1, h2, e1, e2, length(P(:).'), dep_p, dep_f);

dP = reshape(dy((1:3:end),:), length(P), length(P), length(P));
dF1 = reshape(dy((2:3:end),:), length(P), length(P), length(P));
dF2 = reshape(dy((3:3:end),:), length(P), length(P), length(P));

u = dP ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
v = dF1 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
w = dF2 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);

figure;
quiver3(P, F1, F2, u, v, w, 0.35);
xlabel('P');
ylabel('F1');
zlabel('F2');
hold on;

#+end_src

*** Plot isoclines

#+begin_src matlab :tangle phenophase.m

syms x y z
eq1 = ((1-dep_p).*r_p + dep_p .* (c1.*((alpha_pf(1).*y)./(h2(1)+y) + (alpha_pf(2).*z)./(h2(2)+z)))- ((dep_f(1)+dep_f(2))/2) .*(q1.*(beta1.*(y + z)./(e1+x)))-(d_p.*x));
eq2 = ((1-dep_f(1)).*r_f(1) + c2 .*(dep_f(1).*(alpha_fp(1).*x)./(h1(1)+x))-q2.*(dep_p.*((beta2(1).*x)./(e2(1)+y))) -(d_f(1).*y));
eq3 = ((1-dep_f(2)).*r_f(2) + c2 .*(dep_f(2).*(alpha_fp(2).*x)./(h1(2)+x))-q2.*(dep_p.*((beta2(2).*x)./(e2(2)+z))) -(d_f(2).*z));

fimplicit3(eq1, [0 maxpop]);
fimplicit3(eq2, [0 maxpop]);
fimplicit3(eq3, [0 maxpop]);

hold off;

#+end_src


* System of Equations (=odephenotypes.m=)

** Function definition

Note that now =r2=, =alpha12=, =alpha21=, =beta2=, =d2=, =h1=, =h2=, =e2=, and =dep_f= are /1x2/ vectors. The first value is for $F_1$, the second is for $F_2$ (e.g. =r2(1)= if $F_2$'s growth rate)

#+begin_src matlab :tangle odephenotypes.m

function dydt = odephenotypes(t,y,r1,r2,alpha12,alpha21,q1,q2,beta1,beta2,c1,c2,d1,d2,h1,h2,e1,e2,nodes,dep_p,dep_f)
y = reshape(y,3,nodes);
dydt  = zeros(size(y));

#+end_src

** Species /P/

$$
\frac{dP}{dt} = P\left [
(1 - \delta_P) r_P + \delta_P \left( c_1 \left[\frac{\alpha_{PF_1} F_1}{h_P_1 + F_1}  + \frac{\alpha_{PF_2} F_2}{h_P_2 + F_2} \right] \right) -
\left(\frac{\delta_{F1} + \delta_{F2}}{2} \right) \left( q_1 \left[ \frac{\beta_{PF} (F_1 + F_2)}{e_P + P} \right] \right) - d_P P
\right]
$$

#+begin_src matlab :tangle odephenotypes.m

% rename variables so equations are easier to read
P = y(1,:);
F1 = y(2,:);
F2 = y(3,:);

dydt(1,:) = P.*((1-dep_p)*r1 + dep_p * (c1*((alpha12(1).*F1)./(h2(1)+F1) + (alpha12(2).*F2)./(h2(2)+F2)))- ((dep_f(1)+dep_f(2))/2) *(q1*(beta1.*(F1 + F2)./(e1+P)))-(d1.*P));

#+end_src

** Species /F/, Phenotype 1

$$
\frac{dF_1}{dt} = F_1[(1 - \delta_{F_1})r_{F_1} + \delta_{F_1} \left( c_2 \left[\frac{\alpha_{F_1P}P}{h_{F_1} + P} \right] \right) - \delta_P \left(q_2  \left[ \frac{\beta_{F_1P}P}{e_{F_1} + F_1} \right] \right) - d_{F_1}F_1]
$$

#+begin_src matlab :tangle odephenotypes.m

dydt(2,:) = F1.*((1-dep_f(1))*r2(1) + c2 *(dep_f(1)*(alpha21(1).*P)./(h1(1)+P))-q2*(dep_p*((beta2(1).*P)./(e2(1)+F1))) -(d2(1).*F1));

#+end_src

** Species /F/, Phenotype 2

$$
\frac{dF_2}{dt} = F_2[(1 - \delta_{F_2})r_{F_2} + \delta_{F_2} \left(c_2 \left[\frac{\alpha_{F_2P}P}{h_{F_2} + P} \right] \right) - \delta_P \left(q_2  \left[ \frac{\beta_{F_2P}P}{e_{F_2} + F_2} \right] \right) - d_{F_1}F_1]
$$

#+begin_src matlab :tangle odephenotypes.m

dydt(3,:) = F2.*((1-dep_f(2))*r2(2) + c2 *(dep_f(2)*(alpha21(2).*P)./(h1(2)+P))-q2*(dep_p*((beta2(2).*P)./(e2(2)+F2))) -(d2(2).*F2));

#+end_src

** Reshape

#+begin_src matlab :tangle odephenotypes.m

dydt = reshape(dydt,3*nodes,1);
end

#+end_src

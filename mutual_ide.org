#+title: Mutualism IDE Model

* Model

** ODE parameters

#+begin_src matlab :tangle mutual_ide.m

clc
%% original function parameters

iterations = 30;
tspan = [0, 10];
r_p = 0.3;
r_f = [0.30 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.8 0.9];

#+end_src

** Initialization

#+begin_src matlab :tangle mutual_ide.m

%% Initialize parameters
lowval = 1e-9;
diameter = 1200;  %total size of landscape along positive x-axis (so technically half the size of the total landscape)
nodes = (2^16)+1; %total points in space -- 65537
radius = diameter/2;
x = linspace(-radius,radius,nodes);
x2 = linspace(-diameter,diameter,2*nodes-1);
dx = diameter/(nodes-1);
[speed_inst_P,speed_av_P, speed_inst_F1,speed_av_F1, speed_inst_F2, speed_av_F2] = deal(zeros(1,iterations)); %assign initializing values to each of the arrays
[xright_P,xright_F1, xright_F2] = deal(zeros(1,iterations+1)); %array with 1 row and 201 columns. tells us the farthest a population has reached
[n_P,n_F1, n_F2] = deal(zeros(iterations+1,length(x))); %array with 201 rows and 65537 columns. tells us population density at each node along column and each time step/iteration is one row. define ,f_P_all,f_F_all if you wish to do post census calculations

irad = 2;       % Intial condition range%irad_F = 2;% irad_F = diameter if you want to study STE (semi trivial equlibria);
                %irad_F = 2;
idens = [0.1,0.1];
ncrit = 0.05;   % critical threshold for edge of wave
sigma_sq = 0.25;            % Dispersal variance
k_P = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq); % this line and the next describes a gaussian dispersal kernel
k_F = exp(-(x2.^2)/(2*sigma_sq))./sqrt(2*pi*sigma_sq); %make k_F = 0 for STE to prevent dispersal of individuals which are already in the entire space (F is arbit. -- could be P as well)

% k_P = exp(-sqrt(2*(x2.^2)/(sigma_sq)))./sqrt(2*sigma_sq); %this line and the next describe a laplacian dispersal kernel
% k_F = exp(-sqrt(2*(x2.^2)/(sigma_sq)))./sqrt(2*sigma_sq);

% SET THE INITIAL CONDITIONS
temp_P = find(abs(x) <= irad); %locate all values in the array x that lie b/w +irad and -irad units of space
temp_F1 = find(abs(x) <= irad); %irad_F for STE
temp_F2 = find(abs(x) <= irad); %irad_F for STE

n_P(1,temp_P) = idens(1)*normpdf(x(temp_P),0,1); %Computes pdf values evaluated at the values in x i.e. all x(temp) values for the normal distribution with mean 0 and standard deviation 1.
n_F1(1,temp_F1) = idens(2)*normpdf(x(temp_F1),0,1); %Would be just idens(2) for STE
n_F2(1,temp_F2) = idens(2)*normpdf(x(temp_F2),0,1); %Would be just idens(2) for STE
%2 Lines below are for studying spatial spread with census after growth
% f_P_all(1,temp_P) = idens(1)*normpdf(x(temp_P),0,1); %Computes pdf values evaluated at the values in x i.e. all x(temp) values for the normal distribution with mean 0 and standard deviation 1.
% f_F_all(1,temp_F) = idens(2)*normpdf(x(temp_F),0,1);

% FIND THE INITIAL FRONT LOCATION
jj_P = find(n_P(1,:) >= ncrit,1,'last'); %find the farthest distance travelled by the population above a certain threshold density and assign it to jj
jj_F1 = find(n_F1(1,:) >= ncrit,1,'last'); %remove all jj_F mentions if you want to calculate speeds of semi trivial equilibria
jj_F2 = find(n_F2(1,:) >= ncrit,1,'last');

%2 Lines below are for studying spatial spread with census after growth
% f_jj_P = find(f_P_all(1,:) >= ncrit,1,'last'); %find the farthest distance travelled by the population above a certain threshold density and assign it to jj
% f_jj_F = find(f_F_all(1,:) >= ncrit,1,'last');

if jj_P %the initial front is obtained from initialization which will be in the first row of 'n'
  xright_P(1) = interp1(n_P(1,jj_P:jj_P+1),x(jj_P:jj_P+1),ncrit);
end
if jj_F1
  xright_F1(1) = interp1(n_F1(1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),ncrit);
end

if jj_F2
  xright_F2(1) = interp1(n_F2(1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),ncrit);
end
%6 Lines below are for studying spatial spread with census after growth
% if f_jj_P %the initial front is obtained from initialization which will be in the first row of 'n'
%   xright_P(1) = interp1(f_P_all(1,f_jj_P:f_jj_P+1),x(f_jj_P:f_jj_P+1),ncrit);
% end
% if f_jj_F
%   xright_F(1) = interp1(f_F_all(1,f_jj_F:f_jj_F+1),x(f_jj_F:f_jj_F+1),ncrit);
% end

#+end_src

** Growth and dispersal

#+begin_src matlab :tangle mutual_ide.m

%% Looping for growth and dispersal
for i = 1:iterations
    %Growth
    y0 = [n_P(i,:);n_F1(i,:);n_F2(i,:)];
    y0 = reshape(y0, 3*length(y0), 1); % reshape happens such that pairs of n_P and n_F values are located in adjacent rows to each other
    [t,y] = ode45(@(t,y) odephenotypes(t,y,r_p,r_f,alpha_pf,alpha_fp,q1,q2,beta1,beta2,c1,c2,d_p,d_f,h1,h2,e1,e2,nodes,dep_p,dep_f), tspan, y0); %remember to alter where the dep_p and dep_f are being called from
    f_P = y(end,(1:3:end));
    f_F1 = y(end,(2:3:end));
    f_F2 = y(end,(3:3:end));
%6 Lines below are for studying spatial spread with census after growth
%     f_P_all(i+1,:) = f_P;
%     f_F_all(i+1,:) = f_F;
%     temp_P = find(f_P_all(i+1,:) < lowval); %gives location of random places where numbers are above zero due to some numerical errors
%     temp_F = find(f_F_all(i+1,:) < lowval);
%     f_P_all(i+1,temp_P) = zeros(size(f_P_all(i+1,temp_P))); %set the places with those numerical errors to zero
%     f_F_all(i+1,temp_F) = zeros(size(f_F_all(i+1,temp_F)));
%

%   DISPERSAL
    n1_P = fft_conv(k_P,f_P);   % dispersing individuals
    n1_F1 = fft_conv(k_F,f_F1);
    n1_F2 = fft_conv(k_F,f_F2);

    n_P(i+1,:) = dx*n1_P(nodes:length(x2)); %the convolution apparently doubles the length of the array?
    n_F1(i+1,:) = dx*n1_F1(nodes:length(x2)); %MAKE n_F(i+1, :) = r_f/d_f if you want to look at cases of semi-trivial equilibrium;
    n_F2(i+1,:) = dx*n1_F2(nodes:length(x2)); %MAKE n_F(i+1, :) = r_f/d_f if you want to look at cases of semi-trivial equilibrium;

    n_P(i+1,1) = n_P(i+1,1)/2; n_P(i+1,nodes) = n_P(i+1,nodes)/2; %The population density at the edges is halved
    n_F1(i+1,1) = n_F1(i+1,1)/2; n_F1(i+1,nodes) = n_F1(i+1,nodes)/2;
    n_F2(i+1,1) = n_F2(i+1,1)/2; n_F2(i+1,nodes) = n_F2(i+1,nodes)/2;

    temp_P = find(n_P(i+1,:) < lowval); %gives location of random places where numbers are above zero due to some numerical errors
    temp_F1 = find(n_F1(i+1,:) < lowval);%delete this for STE
    temp_F2 = find(n_F2(i+1,:) < lowval);%delete this for STE

    n_P(i+1,temp_P) = zeros(size(n_P(i+1,temp_P))); %set the places with those numerical errors to zero
    n_F1(i+1,temp_F1) = zeros(size(n_F1(i+1,temp_F1)));%delete this for STE
    n_F2(i+1,temp_F2) = zeros(size(n_F2(i+1,temp_F2)));%delete this for STE

    jj_P = find(n_P(i+1,:) >= ncrit,1,'last');
    jj_F1 = find(n_F1(i+1,:) >= ncrit,1,'last');
    jj_F2 = find(n_F2(i+1,:) >= ncrit,1,'last');

%     %2 Lines below are for studying spatial spread with census after growth
%     f_jj_P = find(f_P_all(i+1,:) >= ncrit,1,'last');
%     f_jj_F = find(f_F_all(i+1,:) >= ncrit,1,'last');

    if jj_P
         xright_P(i+1) = interp1(n_P(i+1,jj_P:jj_P+1),x(jj_P:jj_P+1),ncrit);
    end

    if jj_F1
         xright_F1(i+1) = interp1(n_F1(i+1,jj_F1:jj_F1+1),x(jj_F1:jj_F1+1),ncrit);
    end

    if jj_F2
         xright_F2(i+1) = interp1(n_F2(i+1,jj_F2:jj_F2+1),x(jj_F2:jj_F2+1),ncrit);
    end

%6 Lines below are for studying spatial spread with census after growth
%     if f_jj_P
%          xright_P(i+1) = interp1(f_P_all(i+1,f_jj_P:f_jj_P+1),x(f_jj_P:f_jj_P+1),ncrit);
%     end
%
%     if f_jj_F
%          xright_F(i+1) = interp1(f_F_all(i+1,f_jj_F:f_jj_F+1),x(f_jj_F:f_jj_F+1),ncrit);
%     end
%

    speed_av_P(i) = (xright_P(i+1)-xright_P(1))/i; %latest position of wave edge - initial position of wave edge divided by time
    speed_inst_P(i) = xright_P(i+1)-xright_P(i);



    speed_inst_F1(i) = xright_F1(i+1)-xright_F1(i);
    speed_av_F1(i) = (xright_F1(i+1)-xright_F1(1))/i; %latest position of wave edge - initial position of wave edge divided by time

    speed_inst_F2(i) = xright_F2(i+1)-xright_F2(i);
    speed_av_F2(i) = (xright_F2(i+1)-xright_F2(1))/i; %latest position of wave edge - initial position of wave edge divided by time

    %save(strcat(['mandm_yescost_depP=' num2str(dep_p) '_depF=' num2str(dep_f) '.mat']))
    %save mandm_nocost_yesdep.mat

end


#+end_src

* Figures

** 3D density vs. space vs. time plots

#+begin_src matlab :tangle mutual_ide.m

%% Figure for species P
figure(1);
clf
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_P;
nlow(n_P>=ncrit) = NaN;
n_P(n_P<ncrit) = NaN;
hold on
for i = 1:11
     plot3(xx(i,:),tt(i,:),n_P(i,:),'r');
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end
plot3(xright_P(1:11),0:10,ncrit*ones(1,11),'k');
    axis([-15 15 0 10 0 5]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('species P density (n_P)');
    title('Species P');
    view(30,30);

%% Figure for species F1
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_F1;
nlow(n_F1>=ncrit) = NaN;
n_F1(n_F1<ncrit) = NaN;
hold on
for i = 1:11
     plot3(xx(i,:),tt(i,:),n_F1(i,:),'g');
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end
plot3(xright_F1(1:11),0:10,ncrit*ones(1,11),'k');
    axis([-15 15 0 10 0 5]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('species F1 density (n_F1)');
    view(30,30);
    title('Species F1');

%% Figure for species F2
[xx,tt] = meshgrid(x,0:iterations);
nlow = n_F2;
nlow(n_F2>=ncrit) = NaN;
n_F2(n_F2<ncrit) = NaN;
hold on
for i = 1:11
     plot3(xx(i,:),tt(i,:),n_F2(i,:),'b');
     plot3(xx(i,:),tt(i,:),nlow(i,:),'Color',0.8*[1 1 1]);
     grid on
end
plot3(xright_F2(1:11),0:10,ncrit*ones(1,11),'k');
    axis([-15 15 0 10 0 5]);
    xlabel('space (x)');
    ylabel('time (t)');
    zlabel('species F2 density (n_F2)');
    view(30,30);
    title('Species F2');
hold off

#+end_src

** Density vs. time plots

#+begin_src matlab :tangle no

t= 0:iterations;
plot(t, n_P, t, n_F1, t, n_F2)

#+end_src

** Phase space plot

In the two-species mutualism model, we took a range of possible starting population values (this is what we passed to the =meshgrid()= function to generate a matrix for each species). We then sent these matrices to our ODE function, which returned the growth rates for each combination of starting population values—this is how we got our vector field arrows.

*** Initial setup for 3D phase space plot

Here you generate the vector field with the =meshgrid()= and =quiver()= functions

#+begin_src matlab :tangle phenophase.m

maxpop = 10.0;
popRange = 0.0:0.5:maxpop;

[P, F1, F2] = meshgrid(popRange);

r_p = 0.3;
r_f = [0.50 0.30];
alpha_pf = [0.5 0.5];
alpha_fp = [0.5 0.5];
q1 = 1.0;
q2 = 1.0;
beta1 = 0.0;
beta2 = [0.0 0.0];
c1 = 1.0;
c2 = 1.0;
d_p = 0.1;
d_f = [0.1 0.1];
h1 = [0.3 0.3];
h2 = [0.3 0.3];
e1 = 0.3;
e2 = [0.3 0.3];
dep_p = 0.0;
dep_f = [0.4 0.9];


ystart = [P(:).'; F1(:).'; F2(:).'];
ystart = reshape(ystart, 3*length(ystart), 1);

dy = odephenotypes(0, ystart, r_p, r_f, alpha_pf, alpha_fp, q1, q2, beta1, beta2, c1, c2, d_p, d_f, h1, h2, e1, e2, length(P(:).'), dep_p, dep_f);

dP = reshape(dy((1:3:end),:), length(P), length(P), length(P));
dF1 = reshape(dy((2:3:end),:), length(P), length(P), length(P));
dF2 = reshape(dy((3:3:end),:), length(P), length(P), length(P));

u = dP ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
v = dF1 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);
w = dF2 ./ sqrt(dP .^ 2 + dF1 .^2 + dF2 .^ 2);

figure;
quiver3(P, F1, F2, u, v, w, 0.35);
xlabel('P');
ylabel('F1');
zlabel('F2');
hold on;

#+end_src

*** Plot isoclines

#+begin_src matlab :tangle phenophase.m

syms x y z
eq1 = ((1-dep_p).*r_p + dep_p .* (c1.*((alpha_pf(1).*y)./(h2(1)+y) + (alpha_pf(2).*z)./(h2(2)+z)))- ((dep_f(1)+dep_f(2))/2) .*(q1.*(beta1.*(y + z)./(e1+x)))-(d_p.*x));
eq2 = ((1-dep_f(1)).*r_f(1) + c2 .*(dep_f(1).*(alpha_fp(1).*x)./(h1(1)+x))-q2.*(dep_p.*((beta2(1).*x)./(e2(1)+y))) -(d_f(1).*y));
eq3 = ((1-dep_f(2)).*r_f(2) + c2 .*(dep_f(2).*(alpha_fp(2).*x)./(h1(2)+x))-q2.*(dep_p.*((beta2(2).*x)./(e2(2)+z))) -(d_f(2).*z));

fimplicit3(eq1, [0 maxpop]);
fimplicit3(eq2, [0 maxpop]);
fimplicit3(eq3, [0 maxpop]);

hold off;

#+end_src


* System of Equations (=odephenotypes.m=)

** Function definition

Note that now =r2=, =alpha12=, =alpha21=, =beta2=, =d2=, =h1=, =h2=, =e2=, and =dep_f= are /1x2/ vectors. The first value is for $F_1$, the second is for $F_2$ (e.g. =r2(1)= if $F_2$'s growth rate)

#+begin_src matlab :tangle odephenotypes.m

function dydt = odephenotypes(t,y,r1,r2,alpha12,alpha21,q1,q2,beta1,beta2,c1,c2,d1,d2,h1,h2,e1,e2,nodes,dep_p,dep_f)
y = reshape(y,3,nodes);
dydt  = zeros(size(y));

#+end_src

** Species /P/

$$
\frac{dP}{dt} = P\left [
(1 - \delta_P) r_P + \delta_P \left( c_1 \left[\frac{\alpha_{PF_1} F_1}{h_P_1 + F_1}  + \frac{\alpha_{PF_2} F_2}{h_P_2 + F_2} \right] \right) -
\left(\frac{\delta_{F1} + \delta_{F2}}{2} \right) \left( q_1 \left[ \frac{\beta_{PF} (F_1 + F_2)}{e_P + P} \right] \right) - d_P P
\right]
$$

#+begin_src matlab :tangle odephenotypes.m

% rename variables so equations are easier to read
P = y(1,:);
F1 = y(2,:);
F2 = y(3,:);

dydt(1,:) = P.*((1-dep_p)*r1 + dep_p * (c1*((alpha12(1).*F1)./(h2(1)+F1) + (alpha12(2).*F2)./(h2(2)+F2)))- ((dep_f(1)+dep_f(2))/2) *(q1*(beta1.*(F1 + F2)./(e1+P)))-(d1.*P));

#+end_src

** Species /F/, Phenotype 1

$$
\frac{dF_1}{dt} = F_1[(1 - \delta_{F_1})r_{F_1} + \delta_{F_1} \left( c_2 \left[\frac{\alpha_{F_1P}P}{h_{F_1} + P} \right] \right) - \delta_P \left(q_2  \left[ \frac{\beta_{F_1P}P}{e_{F_1} + F_1} \right] \right) - d_{F_1}F_1]
$$

#+begin_src matlab :tangle odephenotypes.m

dydt(2,:) = F1.*((1-dep_f(1))*r2(1) + c2 *(dep_f(1)*(alpha21(1).*P)./(h1(1)+P))-q2*(dep_p*((beta2(1).*P)./(e2(1)+F1))) -(d2(1).*F1));

#+end_src

** Species /F/, Phenotype 2

$$
\frac{dF_2}{dt} = F_2[(1 - \delta_{F_2})r_{F_2} + \delta_{F_2} \left(c_2 \left[\frac{\alpha_{F_2P}P}{h_{F_2} + P} \right] \right) - \delta_P \left(q_2  \left[ \frac{\beta_{F_2P}P}{e_{F_2} + F_2} \right] \right) - d_{F_1}F_1]
$$

#+begin_src matlab :tangle odephenotypes.m

dydt(3,:) = F2.*((1-dep_f(2))*r2(2) + c2 *(dep_f(2)*(alpha21(2).*P)./(h1(2)+P))-q2*(dep_p*((beta2(2).*P)./(e2(2)+F2))) -(d2(2).*F2));

#+end_src

** Reshape

#+begin_src matlab :tangle odephenotypes.m

dydt = reshape(dydt,3*nodes,1);
end

#+end_src
